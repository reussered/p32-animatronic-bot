// spi_display_bus driver implementation
// Provides dedicated SPI bus allocation for display peripherals

#include "esp_log.h"
#include "esp_system.h"
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp32_s3_r8n16_pin_assignments.h"
#include "components/spi_display_bus.hdr"
#include "components/creature_specific/goblin_eye.hdr"  // For hardware init flag

#include <stddef.h>
#include <stdio.h>

// Forward declaration for function used by spi_display_bus_act
esp_err_t spi_display_bus_transmit_chunk(Pixel* chunk_data, uint32_t pixel_count, uint8_t display_id);

static constexpr size_t SPI_DISPLAY_SLOT_COUNT = 32U;
static spi_display_pinset_t spi_display_slots[SPI_DISPLAY_SLOT_COUNT];
spi_display_pinset_t cur_spi_display_pin;

static const char *TAG_spi_display_bus = "spi_display_bus";

static spi_display_pinset_t shared_display_pins;

static int get_next_assignable(const int *assignable, size_t assignable_count) {
    for (size_t i = 0; i < assignable_count; ++i) {
        const int candidate = assignable[i];
        bool already_claimed = false;
        for (size_t j = 0; j < assigned_pins_count; ++j) {
            if (assigned_pins[j] == candidate) {
                already_claimed = true;
                break;
            }
        }

        if (!already_claimed) {
            if (assigned_pins_count >= (sizeof(assigned_pins) / sizeof(assigned_pins[0]))) {
                ESP_LOGE(TAG_spi_display_bus, "Assigned pin buffer exhausted");
                esp_system_abort("Assigned pin buffer exhausted");
            }

            assigned_pins[assigned_pins_count++] = candidate;
            return candidate;
        }
    }

    ESP_LOGE(TAG_spi_display_bus, "No assignable pins remain for SPI display bus");
    esp_system_abort("SPI display bus ran out of assignable pins");
    return -1;
}

esp_err_t spi_display_bus_init(void) {
    static size_t device_count = 0;

    // CRITICAL GUARD: Check if parent (goblin_eye) wants hardware initialization
    // This flag is set true only every 8th call (once per physical display)
    if (!goblin_eye_should_init_hardware)
    {
        ESP_LOGD(TAG_spi_display_bus, "Skipping SPI bus init (goblin_eye_should_init_hardware = false)");
        return ESP_OK;  // Skip hardware init, return success
    }

    if (device_count >= SPI_DISPLAY_SLOT_COUNT) 
    {
        ESP_LOGE(TAG_spi_display_bus, "No remaining SPI display device slots available");
        return ESP_FAIL;
    }

    // On the very first call, allocate shared pins and initialize the bus
    if (device_count == 0) 
    {
        spi_display_slots[0].mosi = get_next_assignable(spi_assignable, spi_assignable_count);
        spi_display_slots[0].clk = get_next_assignable(spi_assignable, spi_assignable_count);
        spi_display_slots[0].rst = get_next_assignable(spi_assignable, spi_assignable_count);

        spi_bus_config_t bus_cfg = {
            .mosi_io_num = spi_display_slots[0].mosi,
            .miso_io_num = -1,
            .sclk_io_num = spi_display_slots[0].clk,
            .quadwp_io_num = -1,
            .quadhd_io_num = -1,
            .max_transfer_sz = 240 * 240 * 2 + 8,
            .flags = SPICOMMON_BUSFLAG_MASTER,
            .intr_flags = 0
        };

        const esp_err_t ret = spi_bus_initialize(SPI2_HOST, &bus_cfg, SPI_DMA_CH_AUTO);
        if (ret != ESP_OK) 
        {
            ESP_LOGE(TAG_spi_display_bus, "spi_bus_initialize failed: %s", esp_err_to_name(ret));
            return ret;
        }

        ESP_LOGI(TAG_spi_display_bus,
                 "Shared SPI display pins assigned MOSI:%d CLK:%d RST:%d",
                 spi_display_slots[0].mosi,
                 spi_display_slots[0].clk,
                 spi_display_slots[0].rst);
    }

    // For subsequent devices, copy the shared pin configuration from the first device
    if (device_count > 0)
    {
        spi_display_slots[device_count].mosi = spi_display_slots[0].mosi;
        spi_display_slots[device_count].clk = spi_display_slots[0].clk;
        spi_display_slots[device_count].rst = spi_display_slots[0].rst;
    }

    // For every device (including the first), allocate its unique pins and add to bus
    spi_display_slots[device_count].cs = get_next_assignable(spi_assignable, spi_assignable_count);
    spi_display_slots[device_count].dc = get_next_assignable(spi_assignable, spi_assignable_count);
    spi_display_slots[device_count].bl = get_next_assignable(spi_assignable, spi_assignable_count);
    
    // Configure RST, DC, and BL as outputs
    gpio_config_t io_conf = {};
    io_conf.mode = GPIO_MODE_OUTPUT;
    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
    io_conf.pull_up_en = GPIO_PULLUP_DISABLE;
    io_conf.intr_type = GPIO_INTR_DISABLE;
    
    if (spi_display_slots[device_count].rst != -1) {
        io_conf.pin_bit_mask = (1ULL << spi_display_slots[device_count].rst);
        gpio_config(&io_conf);
        gpio_set_level((gpio_num_t)spi_display_slots[device_count].rst, 1);  // Set high initially
    }
    
    if (spi_display_slots[device_count].dc != -1) {
        io_conf.pin_bit_mask = (1ULL << spi_display_slots[device_count].dc);
        gpio_config(&io_conf);
    }
    
    if (spi_display_slots[device_count].bl != -1) {
        io_conf.pin_bit_mask = (1ULL << spi_display_slots[device_count].bl);
        gpio_config(&io_conf);
        gpio_set_level((gpio_num_t)spi_display_slots[device_count].bl, 1);  // Turn on backlight
    }
    
    spi_device_interface_config_t dev_cfg = {
        .command_bits = 0,
        .address_bits = 0,
        .dummy_bits = 0,
        .mode = 0,
        .duty_cycle_pos = 0,
        .cs_ena_pretrans = 0,
        .cs_ena_posttrans = 0,
        .clock_speed_hz = 40 * 1000 * 1000, // 40 MHz
        .input_delay_ns = 0,
        .spics_io_num = spi_display_slots[device_count].cs,
        .queue_size = 7,
        .pre_cb = NULL, // Set D/C line high for data
        .post_cb = NULL
    };

    esp_err_t ret = spi_bus_add_device(SPI2_HOST, &dev_cfg, &spi_display_slots[device_count].handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG_spi_display_bus, "spi_bus_add_device failed for CS=%d: %s", spi_display_slots[device_count].cs, esp_err_to_name(ret));
        return ret;
    }

    ESP_LOGI(TAG_spi_display_bus,
             "Display slot %u assigned unique pins CS:%d DC:%d BL:%d and handle %p",
             static_cast<unsigned>(device_count),
             spi_display_slots[device_count].cs,
             spi_display_slots[device_count].dc,
             spi_display_slots[device_count].bl,
             (void*)spi_display_slots[device_count].handle);

    // Set cur_spi_display_pin to the device we just created so the next component can use it immediately
    cur_spi_display_pin = spi_display_slots[device_count];

    device_count++;
    return ESP_OK;
}

void spi_display_bus_act(void) 
{
    static int device = 0;

    // If the current device slot is uninitialized, reset to the first device.
    // This handles both the end-of-list and the empty-list cases.
    if (device >= SPI_DISPLAY_SLOT_COUNT || spi_display_slots[device].cs == -1) 
    {
        device = 0;
    }

    // If the first slot is also uninitialized, there's nothing to do.
    if (spi_display_slots[device].cs == -1)
    {
        return;
    }

    // Check if goblin_eye has prepared a chunk for transmission
    extern Pixel* goblin_eye_chunk_buffer;
    extern uint16_t goblin_eye_chunk_width;
    extern uint16_t goblin_eye_chunk_height;

    if (goblin_eye_chunk_buffer && goblin_eye_chunk_width > 0 && goblin_eye_chunk_height > 0) {
        uint32_t pixel_count = goblin_eye_chunk_width * goblin_eye_chunk_height;

        // For full-frame transmission (240x240), let generic_spi_display handle it
        // Only transmit small chunks here
        if (pixel_count <= 240 * 30) {  // Max chunk buffer size
            ESP_LOGV(TAG_spi_display_bus, "Transmitting chunk to display %d (%dx%d = %lu pixels)",
                     device, goblin_eye_chunk_width, goblin_eye_chunk_height, pixel_count);

            // Transmit the chunk
            esp_err_t ret = spi_display_bus_transmit_chunk(goblin_eye_chunk_buffer, pixel_count, device);
            if (ret != ESP_OK) {
                ESP_LOGE(TAG_spi_display_bus, "Failed to transmit chunk to display %d", device);
            }

            // Clear the buffer pointer after transmission
            goblin_eye_chunk_buffer = nullptr;
        } else {
            ESP_LOGV(TAG_spi_display_bus, "Skipping large frame (%dx%d = %lu pixels) - let generic_spi_display handle it",
                     goblin_eye_chunk_width, goblin_eye_chunk_height, pixel_count);
        }
    }

    // Set the current global pinset for other components to use
    cur_spi_display_pin = spi_display_slots[device];

    // Move to the next device for the next call
    device++;
}

/**
 * @brief Transmit a chunk of pixel data to a specific display
 * @param chunk_data Pointer to RGB565 pixel data
 * @param pixel_count Number of pixels in chunk
 * @param display_id Which display slot (0 = left eye, 1 = right eye, etc.)
 * @return ESP_OK on success
 */
esp_err_t spi_display_bus_transmit_chunk(Pixel* chunk_data, uint32_t pixel_count, uint8_t display_id)
{
    if (display_id >= SPI_DISPLAY_SLOT_COUNT || !spi_display_slots[display_id].handle) {
        ESP_LOGE(TAG_spi_display_bus, "Invalid display_id %d or uninitialized handle", display_id);
        return ESP_ERR_INVALID_ARG;
    }

    // Convert RGB888 to RGB565 and transmit
    static uint16_t rgb565_buffer[240 * 30]; // Max chunk size
    if (pixel_count > sizeof(rgb565_buffer) / sizeof(uint16_t)) {
        ESP_LOGE(TAG_spi_display_bus, "Chunk too large: %lu pixels", pixel_count);
        return ESP_ERR_INVALID_SIZE;
    }

    // Convert pixels to RGB565
    for (uint32_t i = 0; i < pixel_count; i++) {
        const Pixel& pixel = chunk_data[i];
        // RGB565 conversion: RRRRRGGGGGGBBBBB
        uint16_t r = (pixel.red >> 3) & 0x1F;    // 5 bits
        uint16_t g = (pixel.green >> 2) & 0x3F;  // 6 bits
        uint16_t b = (pixel.blue >> 3) & 0x1F;   // 5 bits
        rgb565_buffer[i] = (r << 11) | (g << 5) | b;
    }

    // Set D/C line high for data
    gpio_set_level((gpio_num_t)spi_display_slots[display_id].dc, 1);

    // Transmit the chunk
    spi_transaction_t trans = {
        .flags = 0,
        .cmd = 0,
        .addr = 0,
        .length = pixel_count * 16, // 16 bits per pixel (RGB565)
        .rxlength = 0,
        .user = NULL,
        .tx_buffer = rgb565_buffer,
        .rx_buffer = NULL
    };

    esp_err_t ret = spi_device_transmit(spi_display_slots[display_id].handle, &trans);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG_spi_display_bus, "SPI transmit failed for display %d: %s", display_id, esp_err_to_name(ret));
        return ret;
    }

    ESP_LOGV(TAG_spi_display_bus, "Transmitted %lu pixels to display %d", pixel_count, display_id);
    return ESP_OK;
}
