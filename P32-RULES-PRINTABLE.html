<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P32 Architectural Rules Review</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            line-height: 1.6; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 20px;
            color: #333;
        }
        h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        h2 { color: #34495e; margin-top: 30px; }
        h3 { color: #7f8c8d; }
        ul { margin: 10px 0; }
        li { margin: 5px 0; }
        pre { 
            background: #f8f9fa; 
            border: 1px solid #e9ecef; 
            border-radius: 4px; 
            padding: 15px; 
            overflow-x: auto;
            font-family: 'Courier New', monospace;
        }
        code { 
            background: #f1f3f4; 
            padding: 2px 4px; 
            border-radius: 3px; 
            font-family: 'Courier New', monospace;
        }
        strong { color: #2c3e50; }
        @media print {
            body { font-size: 12pt; }
            pre { font-size: 10pt; }
        }
    </style>
</head>
<body>
    <h1>P32 Animatronic Bot - Complete Architectural Ruleset</h1>

    <h2> CRITICAL SETUP (READ FIRST)</h2>
    <ul>
        <li><strong>Project Root</strong>: <code>f:\GitHub\p32-animatronic-bot</code> (fixed location, use absolute paths)</li>
        <li><strong>MANDATORY</strong>: Read this document before any code changes. This consolidates all architectural rules without duplicates.</li>
    </ul>

    <h2> AI Agent Behavior Guidelines</h2>
    <ul>
        <li><strong>Defer to user expertise</strong> as domain expert</li>
        <li><strong>Never delete, modify, or refactor</strong> existing code without explicit permission</li>
        <li><strong>Explain all proposed changes</strong> clearly and get confirmation for significant edits</li>
        <li><strong>Preserve existing code context and intent</strong> - no changes "out of context" or based on external assumptions</li>
    </ul>

    <h2> Architecture Overview</h2>

    <h3>Pure Component System</h3>
    <ul>
        <li>Everything is a component with <code>init()</code>/<code>act()</code> functions</li>
        <li>Main loop iterates components only - no application logic in <code>app_main()</code></li>
    </ul>

    <h3>Component Pattern</h3>
    <pre><code>esp_err_t component_name_init(void);  // Returns ESP_OK on success
void component_name_act(void);        // No args, reports errors via SharedMemory</code></pre>

    <h3>Error Reporting</h3>
    <ul>
        <li>Components report errors through SharedMemory (GSM) for monitoring and user notification</li>
    </ul>

    <h3>Communication</h3>
    <ul>
        <li><strong>Within subsystems</strong>: Components communicate via local memory in aggregated <code>{subsystem}_component_functions.cpp</code> files</li>
        <li><strong>Across subsystems/chips</strong>: Use SharedMemory for all inter-component coordination and global variable communication</li>
        <li><strong>Never call component functions directly</strong> across subsystem boundaries</li>
    </ul>

    <h2> Essential Workflows</h2>
    <ul>
        <li><strong>Generate Components</strong>: <code>python tools/generate_tables.py goblin_full src</code> (reads JSON, creates dispatch tables and aggregates individual component cpp/hpp files into subsystem component_functions.cpp/hpp)</li>
        <li><strong>Build & Flash</strong>: <code>pio run -t upload -t monitor</code></li>
        <li><strong>Validate Config</strong>: <code>.\generate_file_structure.ps1</code></li>
        <li><strong>Multi-Chip Testing</strong>: Use <code>test/distance_eye_test/</code> for SharedMemory mesh validation</li>
    </ul>

    <h2> Critical Constraints</h2>
    <ul>
        <li><strong>ESP32 Variants</strong>: Determined per subsystem by final code analysis and testing</li>
        <li><strong>Real-Time</strong>: Components must return quickly (&lt;10ms), no blocking operations</li>
        <li><strong>Multi-Chip</strong>: SharedMemory broadcasts via internal mesh protocol, never direct function calls</li>
        <li><strong>Build System</strong>: PlatformIO + ESP-IDF, multiple environments for subsystems</li>
    </ul>

    <h2> File Organization</h2>
    <ul>
        <li><strong>Components</strong>: <code>src/components/{name}.cpp</code>, <code>include/components/{name}.hpp</code></li>
        <li><strong>Configs</strong>: <code>config/bots/bot_families/{family}/{bot}.json</code></li>
        <li><strong>Assets</strong>: <code>assets/{animations,sounds}/{creature}/</code> for creature-specific assets, <code>assets/shapes/scad/</code> for shared shapes</li>
        <li><strong>3D Models</strong>: Tier 1 (universal hardware) + Tier 2 (creature shells)</li>
    </ul>

    <h2> Integration Points</h2>
    <ul>
        <li><strong>SharedMemory Mesh</strong>: <code>SharedMemory::write()</code> broadcasts to all chips</li>
        <li><strong>Hardware Interfaces</strong>: SPI bus + device pattern, I2S shared bus + unique pins</li>
        <li><strong>Coordinate Systems</strong>: 2D planar or 3D skull-based with <code>"reference_point": "nose_center"</code></li>
        <li><strong>PowerShell Tooling</strong>: All scripts lowercase, absolute paths required</li>
    </ul>

    <h2> Component Relationships & JSON Interpretation</h2>

    <h3>Three-Level Hierarchy</h3>
    <ul>
        <li><strong>System Level</strong>: Core platform (WiFi, Serial, Watchdog) - always present</li>
        <li><strong>Family Level</strong>: Behavior/personality shared across bot family (Goblin, Cat, Bear)</li>
        <li><strong>Bot-Specific Level</strong>: Positioned hardware components (eyes, nose, mouth, sensors)</li>
    </ul>

    <h3>Recursive Composition</h3>
    <ul>
        <li><code>goblin_full.json</code>  <code>goblin_head.json</code>  <code>left_eye.json</code></li>
    </ul>

    <h3>JSON Config System</h3>
    <ul>
        <li>Reference other configs: <code>"author": "config/author.json"</code></li>
        <li>Coordinates: <code>"x": "-1.5 INCH"</code> (always include units)</li>
        <li>Coordinate systems: <code>"coordinate_system": "planar_2d"</code> or <code>"skull_3d"</code></li>
        <li>Required fields: <code>"relative_filename"</code>, <code>"version"</code>, <code>"author"</code></li>
        <li>Shape parameter: Present for hardware-only components (<code>"init_function": "STUB"</code>)</li>
    </ul>

    <h2> Component Development Rules</h2>

    <h3>Component Function Signatures</h3>
    <ul>
        <li><strong>MANDATORY</strong>: All components use NO ARGUMENTS pattern:</li>
    </ul>
    <pre><code>esp_err_t component_name_init(void);  // Returns ESP_OK on success
void component_name_act(void);        // No parameters, accesses global state</code></pre>
    <ul>
        <li><strong>WHY</strong>: Enables dispatch table auto-generation and ensures component isolation.</li>
    </ul>

    <h3>Component Isolation</h3>
    <ul>
        <li><strong>NEVER</strong>: Components call each other directly. Use SharedMemory for communication:</li>
    </ul>
    <pre><code>//  WRONG - Direct component call
goblin_right_eye_act();

//  CORRECT - Use SharedMemory
SharedMemory GSM;
Environment* env = GSM.read&lt;Environment&gt;();</code></pre>

    <h3>Global State Access</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Components access shared state through global variables:</li>
        <ul>
            <li><code>g_loopCount</code>: Current loop iteration (uint64_t)</li>
            <li><code>g_shared_state</code>: Global shared memory instance</li>
        </ul>
        <li><strong>WHY</strong>: Eliminates parameter passing overhead in real-time system.</li>
    </ul>

    <h3>Timing Control</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Use <code>g_loopCount</code> for timing, not delays:</li>
    </ul>
    <pre><code>void component_act(void) {
    if (g_loopCount % 30 == 0) {  // Every 30 loops  500ms at 60Hz
        // Do periodic work
    }
}</code></pre>

    <h3>Memory Management</h3>
    <ul>
        <li><strong>FORBIDDEN</strong>: Dynamic allocation in hot paths. Use static buffers:</li>
    </ul>
    <pre><code>static uint8_t* animation_buffer = nullptr;  //  OK
// std::vector&lt;uint8_t&gt; buffer;  //  FORBIDDEN</code></pre>

    <h2> SharedMemory API Rules</h2>

    <h3>Reading Shared State</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Use template read method:</li>
    </ul>
    <pre><code>SharedMemory GSM;
Mood* curMood = GSM.read&lt;Mood&gt;();
if (curMood != nullptr) {
    uint8_t current_mood = curMood-&gt;mood_value;
}</code></pre>
    <ul>
        <li><strong>WHY</strong>: Template-based type safety eliminates string parameter errors.</li>
    </ul>

    <h3>Writing Shared State</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Use write method to broadcast changes:</li>
    </ul>
    <pre><code>SharedMemory GSM;
Mood* curMood = GSM.read&lt;Mood&gt;();
if (curMood != nullptr) {
    curMood-&gt;mood_value = new_mood;
    GSM.write&lt;Mood&gt;();  // Broadcast to all chips
}</code></pre>

    <h3>Data Types</h3>
    <ul>
        <li><strong>SUPPORTED</strong>: POD types and simple structs. No complex objects with pointers.</li>
        <li><strong>WHY</strong>: ESP-NOW requires serializable data structures.</li>
    </ul>

    <h2> Dispatch Table Generation Rules</h2>

    <h3>Auto-Generation Process</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Use Python tool to generate dispatch tables:</li>
    </ul>
    <pre><code>python tools/generate_tables.py goblin_full src</code></pre>
    <ul>
        <li><strong>WHY</strong>: Maintains consistency between JSON configs and C++ code.</li>
    </ul>

    <h3>Table Structure</h3>
    <ul>
        <li><strong>MANDATORY</strong>: Tables contain function pointers only:</li>
    </ul>
    <pre><code>esp_err_t (*initTable[TABLE_SIZE])(void) = {
    heartbeat_init,
    goblin_left_eye_init,
    // ... auto-generated entries
};

void (*actTable[TABLE_SIZE])(void) = {
    heartbeat_act,
    goblin_left_eye_act,
    // ... auto-generated entries
};</code></pre>

    <h3>Component Registration</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Components listed in JSON config are auto-registered in tables.</li>
        <li><strong>WHY</strong>: Eliminates manual table maintenance errors.</li>
    </ul>

    <h2> Multi-Chip Communication Rules</h2>

    <h3>ESP-NOW Mesh</h3>
    <ul>
        <li><strong>AUTOMATIC</strong>: SharedMemory handles all network communication:</li>
        <ul>
            <li><code>read&lt;T&gt;()</code>: Retrieves latest value from mesh</li>
            <li><code>write&lt;T&gt;()</code>: Broadcasts changes to all chips</li>
        </ul>
    </ul>

    <h3>Mesh Roles</h3>
    <ul>
        <li><strong>DEFINED</strong>: JSON specifies chip roles:</li>
    </ul>
    <pre><code>"mesh_role": "SLAVE_NODE_HIGH_PRIORITY"</code></pre>
    <ul>
        <li><strong>WHY</strong>: Enables hierarchical communication patterns.</li>
    </ul>

    <h3>Synchronization</h3>
    <ul>
        <li><strong>GUARANTEED</strong>: SharedMemory ensures eventual consistency across chips.</li>
        <li><strong>WHY</strong>: Components can assume shared state is current.</li>
    </ul>

    <h2> JSON Configuration Rules</h2>

    <h3>File Structure</h3>
    <ul>
        <li><strong>MANDATORY</strong>: All JSON files include metadata:</li>
    </ul>
    <pre><code>{
    "relative_filename": "config/components/...",
    "version": "1.0.0",
    "author": "config/author.json"
}</code></pre>

    <h3>Coordinate Systems</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Specify coordinate system and units:</li>
    </ul>
    <pre><code>"coordinate_system": "skull_3d",
"reference_point": "nose_center",
"units": "MILLIMETERS"</code></pre>

    <h3>Component Composition</h3>
    <ul>
        <li><strong>HIERARCHICAL</strong>: Components reference other components:</li>
    </ul>
    <pre><code>"contained_components": [
    "config/components/hardware/gc9a01_display.json",
    "config/components/creature_specific/goblin_eye.json"
]</code></pre>

    <h2> Hardware Interface Rules</h2>

    <h3>SPI Bus Sharing</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Multiple devices on shared SPI bus with unique CS pins.</li>
        <li><strong>WHY</strong>: Maximizes pin utilization on ESP32-S3.</li>
    </ul>

    <h3>I2S Audio</h3>
    <ul>
        <li><strong>SHARED</strong>: I2S bus shared across audio components with unique pins.</li>
        <li><strong>WHY</strong>: Enables multiple audio sources.</li>
    </ul>

    <h3>Pin Aliasing</h3>
    <ul>
        <li><strong>MANDATORY</strong>: Use pin aliases instead of GPIO numbers:</li>
    </ul>
    <pre><code>#define PIN_SPI_CS_EYE_LEFT GPIO_NUM_5</code></pre>
    <ul>
        <li><strong>WHY</strong>: Enables hardware abstraction and remapping.</li>
    </ul>

    <h2> Animation & Display Rules</h2>

    <h3>Buffer Management</h3>
    <ul>
        <li><strong>STATIC</strong>: Use static buffers for animation data:</li>
    </ul>
    <pre><code>static uint8_t* left_eye_buffer = nullptr;</code></pre>
    <ul>
        <li><strong>WHY</strong>: Prevents memory fragmentation in real-time system.</li>
    </ul>

    <h3>Frame Timing</h3>
    <ul>
        <li><strong>LOOP-BASED</strong>: Use loop counter for frame advancement:</li>
    </ul>
    <pre><code>if (g_loopCount % 30 == 0) {
    current_frame = (current_frame + 1) % 6;
}</code></pre>

    <h3>Color Palettes</h3>
    <ul>
        <li><strong>MOOD-BASED</strong>: Colors change based on creature mood:</li>
    </ul>
    <pre><code>"mood_color_mapping": {
    "ANGER": {"primary_range": "96-127"}
}</code></pre>

    <h2> Testing & Validation Rules</h2>

    <h3>Component Testing</h3>
    <ul>
        <li><strong>ISOLATED</strong>: Test components independently using mock SharedMemory.</li>
        <li><strong>WHY</strong>: Ensures component isolation is maintained.</li>
    </ul>

    <h3>Multi-Chip Testing</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Use <code>test/distance_eye_test/</code> for mesh validation.</li>
        <li><strong>WHY</strong>: Validates SharedMemory synchronization.</li>
    </ul>

    <h3>Build Validation</h3>
    <ul>
        <li><strong>MANDATORY</strong>: Run <code>pio run</code> before committing.</li>
        <li><strong>WHY</strong>: Catches compilation errors early.</li>
    </ul>

    <h2> Code Style Rules</h2>

    <h3>ASCII Encoding</h3>
    <ul>
        <li><strong>MANDATORY</strong>: All files in ASCII encoding only.</li>
        <li><strong>WHY</strong>: ESP-IDF toolchain requirement.</li>
    </ul>

    <h3>Naming Conventions</h3>
    <ul>
        <li><strong>REQUIRED</strong>:</li>
        <ul>
            <li>Functions: <code>snake_case</code></li>
            <li>Files: <code>lowercase</code></li>
            <li>Classes: <code>PascalCase</code></li>
            <li>Globals: <code>g_camelCase</code></li>
        </ul>
    </ul>

    <h3>Include Guards</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Use <code>#pragma once</code> or standard guards.</li>
        <li><strong>WHY</strong>: Prevents multiple inclusion errors.</li>
    </ul>

    <h2> Development Workflow Rules</h2>

    <h3>Feature Development</h3>
    <ol>
        <li><strong>Design</strong>: Create JSON config first</li>
        <li><strong>Implement</strong>: Write component with init/act functions</li>
        <li><strong>Generate</strong>: Run <code>python tools/generate_tables.py</code></li>
        <li><strong>Build</strong>: <code>pio run -t upload -t monitor</code></li>
        <li><strong>Test</strong>: Validate on hardware</li>
    </ol>

    <h3>Code Changes</h3>
    <ul>
        <li><strong>NEVER</strong>: Modify existing code without user permission.</li>
        <li><strong>WHY</strong>: Preserves architectural integrity.</li>
    </ul>

    <h3>Documentation</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Update this rules document for any architectural changes.</li>
        <li><strong>WHY</strong>: Maintains system consistency.</li>
    </ul>

    <h2> Forbidden Patterns</h2>

    <h3>Direct Component Calls</h3>
    <pre><code>//  NEVER DO THIS
goblin_right_eye_act();
other_component_init();</code></pre>

    <h3>Dynamic Allocation in Hot Paths</h3>
    <pre><code>//  NEVER DO THIS
std::vector&lt;uint8_t&gt; buffer;
auto* ptr = new uint8_t[size];</code></pre>

    <h3>Blocking Operations</h3>
    <pre><code>//  NEVER DO THIS
vTaskDelay(100);
while (!condition) { }</code></pre>

    <h3>Direct ESP-NOW Usage</h3>
    <pre><code>//  NEVER DO THIS
esp_now_send(peer_addr, data, size);</code></pre>

    <h2> Recommended Patterns</h2>

    <h3>Shared State Access</h3>
    <pre><code>SharedMemory GSM;
Environment* env = GSM.read&lt;Environment&gt;();
if (env != nullptr) {
    // Use env-&gt;field
    GSM.write&lt;Environment&gt;();  // If modified
}</code></pre>

    <h3>Recommended Timing Control</h3>
    <pre><code>static uint32_t last_update = 0;
if (g_loopCount - last_update &gt;= 60) {  // Every second at 60Hz
    last_update = g_loopCount;
    // Do periodic work
}</code></pre>

    <h3>Recommended Buffer Management</h3>
    <pre><code>static uint8_t* buffer = nullptr;
if (buffer == nullptr) {
    buffer = getBuffer();  // One-time allocation
}
// Use buffer...</code></pre>

    <h2> Checklist for New Components</h2>
    <ul>
        <li>[ ] JSON config created with required metadata</li>
        <li>[ ] Component implements <code>init()</code> and <code>act()</code> with NO ARGUMENTS</li>
        <li>[ ] Uses SharedMemory for inter-component communication</li>
        <li>[ ] Accesses global state via <code>g_loopCount</code></li>
        <li>[ ] No dynamic allocation in hot paths</li>
        <li>[ ] Uses static buffers for data</li>
        <li>[ ] Tested in isolation</li>
        <li>[ ] Dispatch tables regenerated</li>
        <li>[ ] Builds successfully</li>
        <li>[ ] Validated on hardware</li>
    </ul>

    <h2> Debugging Rules</h2>

    <h3>Log Levels</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Use ESP_LOG macros:</li>
    </ul>
    <pre><code>ESP_LOGI(TAG, "Component initialized");
ESP_LOGE(TAG, "Error: %s", error_msg);</code></pre>

    <h3>Memory Debugging</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Monitor heap usage:</li>
    </ul>
    <pre><code>ESP_LOGI(TAG, "Free heap: %d bytes", esp_get_free_heap_size());</code></pre>

    <h3>Network Debugging</h3>
    <ul>
        <li><strong>REQUIRED</strong>: Monitor ESP-NOW traffic:</li>
    </ul>
    <pre><code>ESP_LOGD(TAG, "Received data from mesh");</code></pre>

    <hr>
    <p><strong>REMEMBER</strong>: This document is the single source of truth for P32 architecture. All rules are mandatory unless explicitly overridden by user instruction. When in doubt, ask the user for clarification rather than making assumptions.</p>
</body>
</html>
