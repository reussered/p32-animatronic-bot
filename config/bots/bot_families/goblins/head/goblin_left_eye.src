// goblin_left_eye.src - Allocate shared display buffer and left eye position
// Component chain: goblin_left_eye (allocate) -> goblin_eye (render) -> generic_spi_display (send & free)

#include "esp_log.h"
#include "esp_heap_caps.h"
#include "shared_headers/color_schema.hpp"

// Note: Display configuration and buffers declared in goblin_eye.src (processed first)

// Eye position (left eye relative to skull center)
struct EyePosition {
    int16_t x;      // -50 = left of center
    int16_t y;      // +30 = above center
    int16_t z;      // -35 = slightly back
} left_eye_position = {-50, 30, -35};

esp_err_t goblin_left_eye_init(void)
{
    // Start with a baseline row count (can be tuned based on available RAM)
    current_row_count = 10;  // Initial: 10 rows at a time
    return ESP_OK;
}

void goblin_left_eye_act(void)
{
    // Allocate buffers if not already done
    if (!front_buffer || !back_buffer)
    {
        // Calculate buffer size based on current row count
        display_size = display_width * current_row_count * bytes_per_pixel;
        
        ESP_LOGI("goblin_left_eye", "Allocating display buffers for left eye (%u rows x %u width, %u bytes each)",
                 current_row_count, display_width, display_size);
            
        // Allocate front buffer (DMA-capable internal RAM)
        front_buffer = (uint8_t*)heap_caps_malloc(display_size, MALLOC_CAP_DMA);
        if (!front_buffer)
        {
            ESP_LOGE("goblin_left_eye", "Failed to allocate %u bytes for front buffer", display_size);
            return;
        }
        
        // Allocate back buffer (DMA-capable internal RAM)
        back_buffer = (uint8_t*)heap_caps_malloc(display_size, MALLOC_CAP_DMA);
        if (!back_buffer)
        {
            ESP_LOGE("goblin_left_eye", "Failed to allocate %u bytes for back buffer", display_size);
            free(front_buffer);
            front_buffer = NULL;
            return;
        }
        
        // Initialize both buffers with neutral color (dark green iris)
        uint16_t neutral = 0x0400;  // RGB565: (0, 8, 0)
        uint16_t* front_u16 = (uint16_t*)front_buffer;
        uint16_t* back_u16 = (uint16_t*)back_buffer;
        
        size_t buffer_size_in_pixels = display_width * current_row_count;
        for (uint32_t i = 0; i < buffer_size_in_pixels; i++) {
            front_u16[i] = neutral;
            back_u16[i] = neutral;
        }
        
        ESP_LOGI("goblin_left_eye", "Display buffers allocated (position: %d,%d,%d mm)",
                 left_eye_position.x, left_eye_position.y, left_eye_position.z);
    }
    
    // === MOOD PROCESSING SECTION ===
    // TODO: Add mood-based eye rendering here
    // This is where goblin_eye rendering logic would go
    
    // Buffers are now allocated and available for the next component in the chain
    // (Data flows via file-scoped static variables in the single compilation unit)
}



 
