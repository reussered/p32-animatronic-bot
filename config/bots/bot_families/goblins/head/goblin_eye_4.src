// goblin_eye_4 component implementation
// Processes 30-row chunks of eye data with mood effects and transmits to display

#include "esp_log.h"
#include "esp_heap_caps.h"
#include "config/components/hardware/gc9a01.hdr"
#include "Mood.hpp"
#include "core/memory/SharedMemory.hpp"
#include "config/components/creature_specific/goblin_eye_shared.hpp"
#include <cmath>
#include <cstring>

static const char *TAG_goblin_eye_4 = "goblin_eye_4";

// Global coordination with goblin_left_eye
extern Pixel* goblin_left_eye_buffer;

// Chunk dimensions (240x30 pixels = 7200 pixels per chunk)
static constexpr uint16_t display_width = 240;
static constexpr uint16_t rows_per_chunk = 30;
static constexpr uint32_t pixels_per_chunk = display_width * rows_per_chunk;

// Instance tracking - this is chunk index 4
static uint8_t my_chunk_index = 4;
static bool initialized_4 = false;

// Local processing buffer (allocated at init)
static Pixel* chunk_buffer_4 = nullptr;

// Global buffer pointer for spi_display_bus
extern Pixel* goblin_eye_chunk_buffer;
extern uint16_t goblin_eye_chunk_width;
extern uint16_t goblin_eye_chunk_height;

// Apply mood effects to a pixel
static Pixel apply_mood_effect_4(Pixel pixel, Mood* mood) {
    if (!mood) return pixel;

    Pixel result = pixel;

    // Apply each mood component's effect
    for (size_t i = 0; i < Mood::componentCount; ++i) {
        float intensity = mood->components[i] / 127.0f;
        if (intensity > 0.0f) {
            const auto& effect = goblin_mood_effects[i];
            result.red = (uint8_t)std::max(0.0f, std::min(255.0f,
                result.red * (1.0f + effect.red_multiplier * intensity)));
            result.green = (uint8_t)std::max(0.0f, std::min(255.0f,
                result.green * (1.0f + effect.green_multiplier * intensity)));
            result.blue = (uint8_t)std::max(0.0f, std::min(255.0f,
                result.blue * (1.0f + effect.blue_multiplier * intensity)));
        }
    }

    return result;
}

esp_err_t goblin_eye_4_init(void) {
    ESP_LOGI(TAG_goblin_eye_4, "Initializing goblin_eye_4 (chunk 4)");

    // Allocate local chunk buffer (7.2KB for 30x240 RGB pixels)
    chunk_buffer_4 = (Pixel*)malloc(pixels_per_chunk * sizeof(Pixel));
    if (!chunk_buffer_4) {
        ESP_LOGE(TAG_goblin_eye_4, "Failed to allocate chunk buffer (%d bytes)",
                 pixels_per_chunk * sizeof(Pixel));
        return ESP_ERR_NO_MEM;
    }

    initialized_4 = true;
    ESP_LOGI(TAG_goblin_eye_4, "Chunk buffer allocated: %.1f KB",
             pixels_per_chunk * sizeof(Pixel) / 1024.0f);

    return ESP_OK;
}

void goblin_eye_4_act(void) {
    if (!initialized_4 || !goblin_left_eye_buffer) {
        return;
    }

    // Copy chunk from PSRAM buffer to local buffer
    uint32_t src_offset = my_chunk_index * pixels_per_chunk;
    memcpy(chunk_buffer_4, &goblin_left_eye_buffer[src_offset], pixels_per_chunk * sizeof(Pixel));

    // Get current mood from shared memory
    Mood* mood = GSM.read<Mood>();
    if (mood) {
        // Apply mood effects to entire chunk
        for (uint32_t i = 0; i < pixels_per_chunk; ++i) {
            chunk_buffer_4[i] = apply_mood_effect_4(chunk_buffer_4[i], mood);
        }
    }

    // Set global chunk buffer for spi_display_bus to transmit
    goblin_eye_chunk_buffer = chunk_buffer_4;
    goblin_eye_chunk_width = display_width;
    goblin_eye_chunk_height = rows_per_chunk;

    ESP_LOGV(TAG_goblin_eye_4, "Processed chunk %d, ready for transmission", my_chunk_index);
}



