// generic_console_display.src - Network display pipeline for PC debugging
// Sends processed buffers to Python visualization server via TCP

#include "esp_log.h"
#include "esp_wifi.h"
#include "lwip/sockets.h"
#include "string.h"

static const char* TAG = "generic_console_display";

// Network connection state
static struct {
    int socket_fd;
    bool connected_to_server;
    uint32_t frames_sent;
} network_state = {
    .socket_fd = -1,
    .connected_to_server = false,
    .frames_sent = 0
};

// Network packet structure
typedef struct {
    uint32_t magic;           // 0xDEADBEEF
    uint32_t frame_number;    // Frame counter
    uint32_t buffer_size;     // Size in bytes
    int16_t eye_x, eye_y, eye_z;  // Eye position
    uint8_t eye_id;           // 0=left, 1=right
    uint8_t data[];           // Pixel data follows
} __attribute__((packed)) display_packet_t;

esp_err_t generic_console_display_init(void)
{
    // TODO: Setup WiFi connection to Windows machine
    // TODO: Connect to Python visualization server on port 5555
    
    ESP_LOGI(TAG, "Generic console display pipeline initialized (network output)");
    return ESP_OK;
}

static bool send_buffer_to_network(DisplayBuffer* buffer, int16_t x, int16_t y, int16_t z, uint8_t eye_id)
{
    if (!network_state.connected_to_server || buffer == NULL || buffer->data == NULL) {
        return false;
    }
    
    // Allocate packet
    size_t packet_size = sizeof(display_packet_t) + BYTES_PER_FRAME;
    display_packet_t* packet = (display_packet_t*)malloc(packet_size);
    if (!packet) {
        ESP_LOGE(TAG, "Failed to allocate network packet");
        return false;
    }
    
    // Fill packet header
    packet->magic = 0xDEADBEEF;
    packet->frame_number = buffer->frame_number;
    packet->buffer_size = BYTES_PER_FRAME;
    packet->eye_x = x;
    packet->eye_y = y;
    packet->eye_z = z;
    packet->eye_id = eye_id;
    
    // Copy pixel data
    memcpy(packet->data, buffer->data, BYTES_PER_FRAME);
    
    // Send to Python server (blocking for now, should be async)
    ssize_t sent = send(network_state.socket_fd, packet, packet_size, 0);
    
    free(packet);
    
    if (sent == packet_size) {
        network_state.frames_sent++;
        ESP_LOGV(TAG, "Sent frame %u to network (%u bytes, eye %u)", 
                 buffer->frame_number, packet_size, eye_id);
        return true;
    } else {
        ESP_LOGW(TAG, "Network send failed: %d/%zu bytes sent", sent, packet_size);
        return false;
    }
}

void generic_console_display_act(void)
{
    // Process buffers in PROCESSED state and send to network
    
    // Left eye front buffer
    if (left_front_buffer.data != NULL && left_front_buffer.state == BUFFER_PROCESSED) {
        if (send_buffer_to_network(&left_front_buffer, 
                                   left_eye_position.x, left_eye_position.y, left_eye_position.z, 0)) {
            left_front_buffer.state = BUFFER_IDLE;
        }
    }
    
    // Left eye back buffer
    if (left_back_buffer.data != NULL && left_back_buffer.state == BUFFER_PROCESSED) {
        if (send_buffer_to_network(&left_back_buffer,
                                   left_eye_position.x, left_eye_position.y, left_eye_position.z, 0)) {
            left_back_buffer.state = BUFFER_IDLE;
        }
    }
    
    // Right eye front buffer
    if (right_front_buffer.data != NULL && right_front_buffer.state == BUFFER_PROCESSED) {
        if (send_buffer_to_network(&right_front_buffer,
                                   right_eye_position.x, right_eye_position.y, right_eye_position.z, 1)) {
            right_front_buffer.state = BUFFER_IDLE;
        }
    }
    
    // Right eye back buffer
    if (right_back_buffer.data != NULL && right_back_buffer.state == BUFFER_PROCESSED) {
        if (send_buffer_to_network(&right_back_buffer,
                                   right_eye_position.x, right_eye_position.y, right_eye_position.z, 1)) {
            right_back_buffer.state = BUFFER_IDLE;
        }
    }
}
