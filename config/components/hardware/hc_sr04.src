// HC-SR04 Ultrasonic Distance Sensor Hardware Component
// Uses gpio_pair_driver for pin management and protocol-correct timing

#include "esp_log.h"
#include "components/drivers/gpio_pair_driver.hdr"

// HC-SR04 pins (configured via dynamic pin assignment)
static int trigger_pin = -1;
static int echo_pin = -1;

// Sound speed constant for distance calculation
#define SOUND_SPEED_CM_US 0.0343f  // Speed of sound: 343 m/s = 0.0343 cm/us

// Measurement state
typedef enum {
    HC_SR04_SENSOR_IDLE = 0,
    HC_SR04_SENSOR_WAITING,      // Waiting for echo measurement
    HC_SR04_SENSOR_READY         // Measurement complete
} hc_sr04_sensor_state_t;

static hc_sr04_sensor_state_t sensor_state = HC_SR04_SENSOR_IDLE;
static float last_distance_cm = 0.0f;
static bool measurement_valid = false;



esp_err_t hc_sr04_init(void) {
    ESP_LOGI("hc_sr04", "Initializing HC-SR04 ultrasonic sensor");
    
    // Initialize the GPIO pair driver first
    esp_err_t ret = gpio_pair_driver_init();
    if (ret != ESP_OK) {
        ESP_LOGE("hc_sr04", "Failed to initialize GPIO pair driver: %s", esp_err_to_name(ret));
        return ret;
    }
    
    // Pin assignment happens via dynamic pin system
    // For now, using example pins - will be assigned dynamically
    trigger_pin = 12;  // Example - will be assigned dynamically
    echo_pin = 13;     // Example - will be assigned dynamically
    
    // Configure the GPIO pair for ultrasonic measurement
    ret = gpio_pair_configure_ultrasonic(trigger_pin, echo_pin);
    if (ret != ESP_OK) {
        ESP_LOGE("hc_sr04", "Failed to configure GPIO pair: %s", esp_err_to_name(ret));
        return ret;
    }
    
    ESP_LOGI("hc_sr04", "HC-SR04 initialized using GPIO pair (trigger: %d, echo: %d)", trigger_pin, echo_pin);
    return ESP_OK;

}



void hc_sr04_act(void) {
    uint32_t pulse_duration_us = 0;
    esp_err_t ret = ESP_ERR_NOT_FINISHED;
    
    switch (sensor_state) {
        case HC_SR04_SENSOR_IDLE:
            // Start new measurement by sending trigger pulse
            ret = gpio_pair_trigger_ultrasonic();
            if (ret == ESP_OK) {
                sensor_state = HC_SR04_SENSOR_WAITING;
                ESP_LOGD("hc_sr04", "Trigger pulse sent, waiting for echo");
            } else if (ret == ESP_ERR_TIMEOUT) {
                // Trigger failed - stay idle and try again next time
                measurement_valid = false;
                ESP_LOGD("hc_sr04", "Trigger failed, will retry");
            } else if (ret == ESP_ERR_INVALID_STATE) {
                // Measurement already in progress - shouldn't happen but handle gracefully
                ESP_LOGD("hc_sr04", "Trigger skipped - measurement already in progress");
            }
            break;
            
        case HC_SR04_SENSOR_WAITING:
            // Check if echo measurement is ready
            ret = gpio_pair_check_echo(&pulse_duration_us);
            if (ret == ESP_OK) {
                // Measurement complete - calculate distance
                last_distance_cm = (pulse_duration_us * SOUND_SPEED_CM_US) / 2.0f;
                measurement_valid = true;
                sensor_state = HC_SR04_SENSOR_READY;
                
                ESP_LOGD("hc_sr04", "Distance: %.2f cm (pulse: %lu us)", last_distance_cm, pulse_duration_us);
                
                // Reset to idle for next measurement cycle
                gpio_pair_reset_measurement();
                sensor_state = HC_SR04_SENSOR_IDLE;
                
            } else if (ret == ESP_ERR_TIMEOUT) {
                // Measurement timed out
                measurement_valid = false;
                sensor_state = HC_SR04_SENSOR_IDLE;
                gpio_pair_reset_measurement();
                ESP_LOGD("hc_sr04", "Measurement timeout");
            }
            // If ret == ESP_ERR_NOT_FINISHED, keep waiting
            break;
            
        case HC_SR04_SENSOR_READY:
            // Measurement is ready, reset to idle for next cycle
            gpio_pair_reset_measurement();
            sensor_state = HC_SR04_SENSOR_IDLE;
            break;
    }
}

/**
 * @brief Get the current distance reading in centimeters
 */
float hc_sr04_get_distance_cm(void) {
    return measurement_valid ? last_distance_cm : -1.0f;
}

/**
 * @brief Check if sensor has a valid reading
 */
bool hc_sr04_is_valid_reading(void) {
    return measurement_valid;
}
