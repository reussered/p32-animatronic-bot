// gc9a01 component implementation
// TEMPLATE-BASED HARDWARE DRIVER
// This component interacts with the physical GC9A01 display.

#include "esp_log.h"
#include "driver/spi_master.h" // For SPI communication
#include <cstdint>

// This is the file-scoped static pointer allocated by the "allocator" component
// (e.g., goblin_left_eye). Because both components are templates instantiated
// with the same type 'T' and concatenated into the same compilation unit,
// this driver component can see and use the buffer allocated by the other.
template <typename T>
extern typename T::Pixel* display_buffer;

static const char *TAG_gc9a01_driver = "gc9a01_driver";

// Placeholder for the SPI device handle
static spi_device_handle_t spi_handle;

template <typename T>
esp_err_t gc9a01_init()
{
    ESP_LOGI(TAG_gc9a01_driver, "Initializing GC9A01 hardware driver (template-based)");

    // In a real scenario, this is where we would initialize the
    // SPI bus, configure the pins, and send initialization commands
    // to the GC9A01 controller.

    // For now, we just log that we are initializing for a specific type.
    ESP_LOGI(TAG_gc9a01_driver, "Driver configured for display: %dx%d", T::WIDTH, T::HEIGHT);

    // Check if the display buffer has been allocated by another component.
    if (display_buffer<T> == nullptr)
    {
        ESP_LOGE(TAG_gc9a01_driver, "Display buffer is null! Allocator component must run first.");
        return ESP_FAIL;
    }

    ESP_LOGI(TAG_gc9a01_driver, "Successfully linked with display buffer.");

    return ESP_OK;
}

template <typename T>
void gc9a01_act()
{
    // This is the core logic of the driver. In every 'act' cycle,
    // it would send the contents of the 'display_buffer' to the
    // physical screen via SPI.

    if (display_buffer<T> == nullptr)
    {
        return; // Not yet initialized
    }

    // --- REAL DRIVER LOGIC WOULD GO HERE ---
    // Example:
    // spi_transaction_t t;
    // memset(&t, 0, sizeof(t));
    // t.length = T::WIDTH * T::HEIGHT * sizeof(typename T::Pixel) * 8; // length in bits
    // t.tx_buffer = display_buffer<T>;
    // spi_device_polling_transmit(spi_handle, &t);
    //
    // For this simulation, we will just confirm we can access the buffer.
    // (This log would be too noisy in a real application)
    // ESP_LOGD(TAG_gc9a01_driver, "gc9a01_act: Acting on display buffer.");
}



