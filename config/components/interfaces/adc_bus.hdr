#ifndef ADC_BUS_HPP
#define ADC_BUS_HPP

/**
 * @file adc_bus.hpp
 * @brief ADC Bus component for ESP32 analog signal conversion
 * @author Auto-generated from JSON specification
 */

#include "esp_err.h"
#include "esp_adc/adc_types.h"

/**
 * @brief Initialize adc_bus component
 * @return ESP_OK on success, esp_err_t error code on failure
 */
esp_err_t adc_bus_init(void);

/**
 * @brief Execute adc_bus component logic
 */
void adc_bus_act(void);

/**
 * @brief Initialize an ADC channel with specified attenuation
 * @param channel ADC channel to configure
 * @param attenuation Attenuation level for the channel
 * @return ESP_OK on success, esp_err_t error code on failure
 */
esp_err_t adc_bus_init_channel(adc_channel_t channel, adc_atten_t attenuation);

/**
 * @brief Read raw ADC value from a channel
 * @param channel ADC channel to read
 * @param raw_value Pointer to store the raw ADC value
 * @return ESP_OK on success, esp_err_t error code on failure
 */
esp_err_t adc_bus_read_raw(adc_channel_t channel, int *raw_value);

/**
 * @brief Read calibrated voltage from an ADC channel
 * @param channel ADC channel to read
 * @param voltage_mv Pointer to store the voltage in millivolts
 * @return ESP_OK on success, esp_err_t error code on failure
 */
esp_err_t adc_bus_read_voltage(adc_channel_t channel, int *voltage_mv);

/**
 * @brief Get the current ADC pins assigned for this act cycle
 * @param pin1 Pointer to store the primary ADC pin GPIO number
 * @param pin2 Pointer to store the secondary ADC pin GPIO number (or -1 if not used)
 * @return ESP_OK on success, esp_err_t error code on failure
 */
esp_err_t adc_bus_get_current_pins(int *pin1, int *pin2);

    bus_initialized = true;
    ESP_LOGI(TAG, "ADC Bus initialized successfully");
    return ESP_OK;
}

esp_err_t adc_bus_init_channel(adc_channel_t channel, adc_atten_t attenuation) {
    if (!bus_initialized) {
        ESP_LOGE(TAG, "ADC bus not initialized");
        return ESP_ERR_INVALID_STATE;
    }

    if (assigned_channel_count >= MAX_ADC_CHANNELS) {
        ESP_LOGE(TAG, "Maximum ADC channels reached");
        return ESP_ERR_NO_MEM;
    }

    esp_err_t ret;

    // Configure ADC channel
    adc_oneshot_chan_cfg_t chan_cfg = {
        .atten = attenuation,
        .bitwidth = ADC_BITWIDTH_DEFAULT,
    };

    ret = adc_oneshot_config_channel(adc1_handle, channel, &chan_cfg);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to configure ADC channel %d: %s", channel, esp_err_to_name(ret));
        return ret;
    }

    // Store assigned channel
    assigned_channels[assigned_channel_count] = channel;
    assigned_channel_count++;

    ESP_LOGI(TAG, "ADC channel %d configured with attenuation %d", channel, attenuation);
    return ESP_OK;
}

esp_err_t adc_bus_read_raw(adc_channel_t channel, int *raw_value) {
    if (!bus_initialized) {
        ESP_LOGE(TAG, "ADC bus not initialized");
        return ESP_ERR_INVALID_STATE;
    }

    esp_err_t ret = adc_oneshot_read(adc1_handle, channel, raw_value);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to read ADC channel %d: %s", channel, esp_err_to_name(ret));
        return ret;
    }

    return ESP_OK;
}

esp_err_t adc_bus_read_voltage(adc_channel_t channel, int *voltage_mv) {
    if (!bus_initialized) {
        ESP_LOGE(TAG, "ADC bus not initialized");
        return ESP_ERR_INVALID_STATE;
    }

    int raw_value;
    esp_err_t ret = adc_bus_read_raw(channel, &raw_value);
    if (ret != ESP_OK) {
        return ret;
    }

    // Find calibration handle for this channel
    for (size_t i = 0; i < assigned_channel_count; i++) {
        if (assigned_channels[i] == channel && cali_handles[i] != NULL) {
            ret = adc_cali_raw_to_voltage(cali_handles[i], raw_value, voltage_mv);
            if (ret != ESP_OK) {
                ESP_LOGE(TAG, "Failed to convert raw to voltage for channel %d: %s", channel, esp_err_to_name(ret));
                return ret;
            }
            return ESP_OK;
        }
    }

    ESP_LOGW(TAG, "No calibration handle found for channel %d, returning raw value * 3300 / 4095", channel);
    *voltage_mv = (raw_value * 3300) / 4095; // Rough approximation
    return ESP_OK;
}

esp_err_t adc_bus_calibration_init(void) {
    ESP_LOGI(TAG, "Initializing ADC calibration scheme");

    // Initialize calibration for all supported schemes
    bool calibrated = false;

    // Try Line Fitting scheme first (most accurate)
    adc_cali_line_fitting_config_t cali_config = {
        .unit_id = ADC_UNIT_1,
        .atten = ADC_ATTEN_DB_11,
        .bitwidth = ADC_BITWIDTH_DEFAULT,
    };

    for (size_t i = 0; i < MAX_ADC_CHANNELS; i++) {
        if (adc_cali_create_scheme_line_fitting(&cali_config, &cali_handles[i]) == ESP_OK) {
            calibrated = true;
            ESP_LOGI(TAG, "ADC calibration scheme initialized for channel slot %d", i);
        }
    }

    if (!calibrated) {
        ESP_LOGW(TAG, "No ADC calibration scheme could be initialized, using raw values");
    }

    return calibrated ? ESP_OK : ESP_ERR_NOT_SUPPORTED;
}

void adc_bus_act(void) {
    // ADC bus act function - currently no periodic operations needed
    // Individual components will call adc_bus_read_* functions as needed
}</content>
<parameter name="filePath">f:\GitHub\p32-animatronic-bot\config\components\interfaces\adc_bus.src