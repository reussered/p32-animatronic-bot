// SPI Bus VSPI Component - Dynamic Pin Assignment
// This component dynamically assigns GPIO pins for SPI bus communication
// init() assigns pins from assignable array, act() manages SPI operations

#include "esp_log.h"
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp32_s3_devkit_pin_assignments.h"
#include "SharedMemory.h"

static const char *TAG = "spi_bus_vspi";

// SPI bus handle
static spi_bus_config_t buscfg;
static spi_host_device_t host = HSPI_HOST;  // VSPI is HSPI_HOST on ESP32-S3
static bool bus_initialized = false;

// Assigned pins (assigned during init, used during act)
static int assigned_mosi = -1;
static int assigned_miso = -1;
static int assigned_sclk = -1;
static int assigned_reset = -1;

// Device-specific pins (up to 4 devices)
static int assigned_cs[4] = {-1, -1, -1, -1};
static int assigned_dc[4] = {-1, -1, -1, -1};
static int assigned_backlight[4] = {-1, -1, -1, -1};

esp_err_t spi_bus_init(void) {
    ESP_LOGI(TAG, "SPI Bus VSPI init - assigning pins dynamically");

    // Assign shared SPI bus pins
    assigned_mosi = assign_pin(gpio_assignable, gpio_assignable_count);
    if (assigned_mosi == -1) {
        ESP_LOGE(TAG, "Failed to assign MOSI pin");
        return ESP_FAIL;
    }

    assigned_miso = assign_pin(gpio_assignable, gpio_assignable_count);
    if (assigned_miso == -1) {
        ESP_LOGE(TAG, "Failed to assign MISO pin");
        return ESP_FAIL;
    }

    assigned_sclk = assign_pin(gpio_assignable, gpio_assignable_count);
    if (assigned_sclk == -1) {
        ESP_LOGE(TAG, "Failed to assign SCLK pin");
        return ESP_FAIL;
    }

    // Assign shared reset pin
    assigned_reset = assign_pin(gpio_assignable, gpio_assignable_count);
    if (assigned_reset == -1) {
        ESP_LOGE(TAG, "Failed to assign RESET pin");
        return ESP_FAIL;
    }

    // Assign device-specific pins (CS, DC, Backlight for up to 4 devices)
    for (int i = 0; i < 4; i++) {
        assigned_cs[i] = assign_pin(gpio_assignable, gpio_assignable_count);
        if (assigned_cs[i] == -1) {
            ESP_LOGE(TAG, "Failed to assign CS pin for device %d", i);
            return ESP_FAIL;
        }

        assigned_dc[i] = assign_pin(gpio_assignable, gpio_assignable_count);
        if (assigned_dc[i] == -1) {
            ESP_LOGE(TAG, "Failed to assign DC pin for device %d", i);
            return ESP_FAIL;
        }

        assigned_backlight[i] = assign_pin(gpio_assignable, gpio_assignable_count);
        if (assigned_backlight[i] == -1) {
            ESP_LOGE(TAG, "Failed to assign Backlight pin for device %d", i);
            return ESP_FAIL;
        }
    }

    ESP_LOGI(TAG, "Assigned SPI pins - MOSI:%d, MISO:%d, SCLK:%d, RESET:%d",
             assigned_mosi, assigned_miso, assigned_sclk, assigned_reset);

    for (int i = 0; i < 4; i++) {
        ESP_LOGI(TAG, "Device %d pins - CS:%d, DC:%d, BL:%d",
                 i, assigned_cs[i], assigned_dc[i], assigned_backlight[i]);
    }

    // Configure SPI bus
    buscfg.mosi_io_num = assigned_mosi;
    buscfg.miso_io_num = assigned_miso;
    buscfg.sclk_io_num = assigned_sclk;
    buscfg.quadwp_io_num = -1;  // Not used
    buscfg.quadhd_io_num = -1;  // Not used
    buscfg.max_transfer_sz = 4096;

    // Initialize SPI bus
    esp_err_t ret = spi_bus_initialize(host, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize SPI bus: %s", esp_err_to_name(ret));
        return ret;
    }

    // Configure reset pin as output
    gpio_config_t reset_conf = {
        .pin_bit_mask = (1ULL << assigned_reset),
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE
    };

    ret = gpio_config(&reset_conf);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to configure RESET pin");
        return ret;
    }

    // Set reset high (active low, so high = not resetting)
    gpio_set_level((gpio_num_t)assigned_reset, 1);

    // Configure device pins as outputs
    for (int i = 0; i < 4; i++) {
        gpio_config_t cs_conf = {
            .pin_bit_mask = (1ULL << assigned_cs[i]),
            .mode = GPIO_MODE_OUTPUT,
            .pull_up_en = GPIO_PULLUP_DISABLE,
            .pull_down_en = GPIO_PULLDOWN_DISABLE,
            .intr_type = GPIO_INTR_DISABLE
        };
        gpio_config(&cs_conf);
        gpio_set_level((gpio_num_t)assigned_cs[i], 1);  // CS high (inactive)

        gpio_config_t dc_conf = {
            .pin_bit_mask = (1ULL << assigned_dc[i]),
            .mode = GPIO_MODE_OUTPUT,
            .pull_up_en = GPIO_PULLUP_DISABLE,
            .pull_down_en = GPIO_PULLDOWN_DISABLE,
            .intr_type = GPIO_INTR_DISABLE
        };
        gpio_config(&dc_conf);
        gpio_set_level((gpio_num_t)assigned_dc[i], 0);  // DC low (command mode)

        gpio_config_t bl_conf = {
            .pin_bit_mask = (1ULL << assigned_backlight[i]),
            .mode = GPIO_MODE_OUTPUT,
            .pull_up_en = GPIO_PULLUP_DISABLE,
            .pull_down_en = GPIO_PULLDOWN_DISABLE,
            .intr_type = GPIO_INTR_DISABLE
        };
        gpio_config(&bl_conf);
        gpio_set_level((gpio_num_t)assigned_backlight[i], 1);  // Backlight on
    }

    bus_initialized = true;
    ESP_LOGI(TAG, "SPI Bus VSPI initialized successfully with dynamic pin assignment");
    return ESP_OK;
}

// Pin access functions for other components
int spi_bus_get_mosi_pin(void) {
    return assigned_mosi;
}

int spi_bus_get_miso_pin(void) {
    return assigned_miso;
}

int spi_bus_get_sclk_pin(void) {
    return assigned_sclk;
}

int spi_bus_get_reset_pin(void) {
    return assigned_reset;
}

int spi_bus_get_cs_pin(int device_index) {
    if (device_index >= 0 && device_index < 4) {
        return assigned_cs[device_index];
    }
    return -1;
}

int spi_bus_get_dc_pin(int device_index) {
    if (device_index >= 0 && device_index < 4) {
        return assigned_dc[device_index];
    }
    return -1;
}

int spi_bus_get_backlight_pin(int device_index) {
    if (device_index >= 0 && device_index < 4) {
        return assigned_backlight[device_index];
    }
    return -1;
}

void spi_bus_act(void) {
    if (!bus_initialized) {
        ESP_LOGW(TAG, "SPI bus not initialized");
        return;
    }

    // Get shared memory for coordination with other components
    // This is where device-specific SPI operations would be coordinated
    // For now, just maintain bus health

    static int loop_count = 0;
    loop_count++;

    // Periodic bus health check (every 100 loops)
    if (loop_count % 100 == 0) {
        ESP_LOGD(TAG, "SPI bus health check - pins assigned and operational");
    }
}