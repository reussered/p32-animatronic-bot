// ADC Bus Component - Dynamic Pin Assignment
// This component dynamically assigns GPIO pins for ADC analog signal conversion
// init() assigns pins into static arrays, act() cycles through pin sets

#include "esp_log.h"
#include "esp_adc/adc_oneshot.h"
#include "esp_adc/adc_cali.h"
#include "esp_adc/adc_cali_scheme.h"
#include "driver/gpio.h"
#include "esp32_s3_r8n16_pin_assignments.h"
#include "core/memory/SharedMemory.hpp"

static const char *TAG = "adc_bus";

// ADC oneshot handle
static adc_oneshot_unit_handle_t adc1_handle;
static bool bus_initialized = false;

// ADC calibration handles
#define MAX_ADC_CHANNELS 8
static adc_cali_handle_t cali_handles[MAX_ADC_CHANNELS] = {NULL};

// Pin sets for multiple ADC devices (up to 4 devices)
#define MAX_PIN_SETS 4
static int assigned_adc_pins[MAX_PIN_SETS] = {-1, -1, -1, -1};
static size_t current_pin_set = 0;
static size_t num_pin_sets = 0;

// ADC unit configuration
static adc_oneshot_unit_init_cfg_t unit_cfg = {
    .unit_id = ADC_UNIT_1,
    .ulp_mode = ADC_ULP_MODE_DISABLE,
};

esp_err_t adc_bus_init(void) {
    ESP_LOGI(TAG, "ADC Bus init - assigning pins dynamically");

    // Assign ADC pins for multiple devices from adc_assignable array
    for (size_t i = 0; i < MAX_PIN_SETS; i++) {
        assigned_adc_pins[i] = assign_pin(adc_assignable, adc_assignable_count);
        if (assigned_adc_pins[i] == -1) {
            ESP_LOGI(TAG, "No more ADC pins available, assigned %d pin sets", i);
            num_pin_sets = i;
            break;
        }
        num_pin_sets = i + 1;
        ESP_LOGI(TAG, "Assigned ADC pin %d for set %d", assigned_adc_pins[i], i);
    }

    if (num_pin_sets == 0) {
        ESP_LOGE(TAG, "No ADC pins available for assignment");
        return ESP_FAIL;
    }

    esp_err_t ret;

    // Initialize ADC unit
    ret = adc_oneshot_new_unit(&unit_cfg, &adc1_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize ADC unit: %s", esp_err_to_name(ret));
        return ret;
    }

    // Initialize calibration scheme
    ret = adc_bus_calibration_init();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize ADC calibration: %s", esp_err_to_name(ret));
        return ret;
    }

    bus_initialized = true;
    ESP_LOGI(TAG, "ADC Bus initialized with %d pin sets", num_pin_sets);
    return ESP_OK;
}

void adc_bus_act(void) {
    if (!bus_initialized) {
        ESP_LOGW(TAG, "ADC bus not initialized");
        return;
    }

    // Assign current ADC pins to the current set
    // The generic driver will use adc_bus_get_current_pins() to get these
    ESP_LOGD(TAG, "ADC bus cycling to pin set %d: GPIO %d", current_pin_set, assigned_adc_pins[current_pin_set]);

    // Move to next pin set
    current_pin_set++;
    if (current_pin_set >= num_pin_sets) {
        current_pin_set = 0; // Reset to beginning when we reach the end
    }
}

// Get current ADC pins for generic driver to use
esp_err_t adc_bus_get_current_pins(int *pin1, int *pin2) {
    if (!bus_initialized) {
        return ESP_ERR_INVALID_STATE;
    }

    if (pin1) *pin1 = assigned_adc_pins[current_pin_set];
    if (pin2) *pin2 = -1; // Single pin per set for now

    return ESP_OK;
}

esp_err_t adc_bus_init_channel(adc_channel_t channel, adc_atten_t attenuation) {
    if (!bus_initialized) {
        ESP_LOGE(TAG, "ADC bus not initialized");
        return ESP_ERR_INVALID_STATE;
    }

    esp_err_t ret;

    // Configure ADC channel
    adc_oneshot_chan_cfg_t chan_cfg = {
        .atten = attenuation,
        .bitwidth = ADC_BITWIDTH_DEFAULT,
    };

    ret = adc_oneshot_config_channel(adc1_handle, channel, &chan_cfg);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to configure ADC channel %d: %s", channel, esp_err_to_name(ret));
        return ret;
    }

    ESP_LOGI(TAG, "ADC channel %d configured with attenuation %d", channel, attenuation);
    return ESP_OK;
}

esp_err_t adc_bus_read_raw(adc_channel_t channel, int *raw_value) {
    if (!bus_initialized) {
        ESP_LOGE(TAG, "ADC bus not initialized");
        return ESP_ERR_INVALID_STATE;
    }

    esp_err_t ret = adc_oneshot_read(adc1_handle, channel, raw_value);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to read ADC channel %d: %s", channel, esp_err_to_name(ret));
        return ret;
    }

    return ESP_OK;
}

esp_err_t adc_bus_read_voltage(adc_channel_t channel, int *voltage_mv) {
    if (!bus_initialized) {
        ESP_LOGE(TAG, "ADC bus not initialized");
        return ESP_ERR_INVALID_STATE;
    }

    int raw_value;
    esp_err_t ret = adc_bus_read_raw(channel, &raw_value);
    if (ret != ESP_OK) {
        return ret;
    }

    // Find calibration handle for this channel
    for (size_t i = 0; i < MAX_ADC_CHANNELS; i++) {
        if (cali_handles[i] != NULL) {
            ret = adc_cali_raw_to_voltage(cali_handles[i], raw_value, voltage_mv);
            if (ret == ESP_OK) {
                return ESP_OK;
            }
        }
    }

    ESP_LOGW(TAG, "No calibration handle found, returning raw value * 3300 / 4095");
    *voltage_mv = (raw_value * 3300) / 4095; // Rough approximation
    return ESP_OK;
}

esp_err_t adc_bus_calibration_init(void) {
    ESP_LOGI(TAG, "Initializing ADC calibration scheme");

    // Initialize calibration for all supported schemes
    bool calibrated = false;

    // Try Line Fitting scheme first (most accurate)
    adc_cali_line_fitting_config_t cali_config = {
        .unit_id = ADC_UNIT_1,
        .atten = ADC_ATTEN_DB_11,
        .bitwidth = ADC_BITWIDTH_DEFAULT,
    };

    for (size_t i = 0; i < MAX_ADC_CHANNELS; i++) {
        if (adc_cali_create_scheme_line_fitting(&cali_config, &cali_handles[i]) == ESP_OK) {
            calibrated = true;
            ESP_LOGI(TAG, "ADC calibration scheme initialized for channel slot %d", i);
        }
    }

    if (!calibrated) {
        ESP_LOGW(TAG, "No ADC calibration scheme could be initialized, using raw values");
    }

    return calibrated ? ESP_OK : ESP_ERR_NOT_SUPPORTED;
}