static const char* TAG = "i2s_debug_driver";

// PC microphone streaming state
static int16_t audio_buffer[512]; // Buffer for incoming PC audio
static size_t buffer_write_pos = 0;
static size_t buffer_read_pos = 0;
static size_t samples_available = 0;
static bool dma_simulated_active = false;
static uint32_t uart_bytes_received = 0;
static uint32_t packets_received = 0;

// UART packet format: [0xAA][0x55][size_low][size_high][audio_data...]
#define PACKET_HEADER_1 0xAA
#define PACKET_HEADER_2 0x55
#define MAX_PACKET_SIZE 1024

// Circular buffer operations
static void buffer_write_sample(int16_t sample)
{
    if (samples_available < 512) {
        audio_buffer[buffer_write_pos] = sample;
        buffer_write_pos = (buffer_write_pos + 1) % 512;
        samples_available++;
    }
}

static int16_t buffer_read_sample(void)
{
    if (samples_available > 0) {
        int16_t sample = audio_buffer[buffer_read_pos];
        buffer_read_pos = (buffer_read_pos + 1) % 512;
        samples_available--;
        return sample;
    }
    return 0; // Silence if no data
}

// Process incoming UART data from PC microphone streamer
static void process_uart_data(void)
{
    // In a real implementation, this would read from UART
    // For now, simulate receiving audio data
    static uint32_t last_uart_check = 0;
    uint32_t current_time = esp_timer_get_time() / 1000;
    
    if (current_time - last_uart_check > 32) { // ~30Hz packet rate (512 samples at 16kHz)
        last_uart_check = current_time;
        
        // Simulate receiving a packet of PC microphone data
        // In real implementation: uart_read_bytes() -> parse packet -> extract samples
        
        // For testing, generate some realistic audio patterns
        static uint32_t sim_time = 0;
        for (int i = 0; i < 64; i++) { // 64 samples per simulated packet
            // Simulate varying audio levels from PC mic
            int16_t sample = 0;
            if ((sim_time / 16000) % 5 < 2) { // 2 seconds on, 3 seconds off pattern  
                sample = (int16_t)(sin(2.0f * 3.14159f * 440.0f * sim_time / 16000.0f) * 8000.0f);
            }
            buffer_write_sample(sample);
            sim_time++;
        }
        
        packets_received++;
        uart_bytes_received += 128; // 64 samples * 2 bytes
        
        ESP_LOGV(TAG, "Received audio packet %lu (buffer: %zu samples)", packets_received, samples_available);
    }
}

esp_err_t i2s_debug_driver_init(void)
{
    ESP_LOGI(TAG, "Initializing I2S debug driver (PC microphone streaming)");
    
    // Initialize UART for receiving PC microphone data
    // In real implementation: configure UART at 921600 baud
    
    // Initialize circular buffer
    buffer_write_pos = 0;
    buffer_read_pos = 0;
    samples_available = 0;
    dma_simulated_active = false;
    uart_bytes_received = 0;
    packets_received = 0;
    
    ESP_LOGI(TAG, "I2S debug driver initialized - ready for PC microphone streaming");
    ESP_LOGI(TAG, "Start PC microphone streamer: python tools/pc_mic_streamer.py");
    ESP_LOGI(TAG, "UART: 921600 baud, expecting 16kHz 16-bit audio packets");
    
    return ESP_OK;
}

void i2s_debug_driver_act(void)
{
    static uint32_t last_dma_check = 0;
    static uint32_t last_stats_report = 0;
    uint32_t current_time = esp_timer_get_time() / 1000;
    
    // Simulate DMA initiation check (same pattern as real driver)
    if (current_time - last_dma_check > 10) // Check every 10ms for smooth audio
    {
        last_dma_check = current_time;
        
        if (!dma_simulated_active)
        {
            dma_simulated_active = true;
            ESP_LOGD(TAG, "Simulated DMA initiated - ready for PC audio streaming");
        }
        
        // Process incoming UART data from PC microphone
        process_uart_data();
    }
    
    // Report streaming statistics every 5 seconds
    if (current_time - last_stats_report > 5000)
    {
        last_stats_report = current_time;
        ESP_LOGI(TAG, "PC Audio Stream: %lu packets, %lu bytes, buffer: %zu samples", 
                packets_received, uart_bytes_received, samples_available);
    }
}

// API Functions (same interface as real i2s_generic_driver)
esp_err_t i2s_debug_driver_read_samples(int32_t *buffer, size_t *bytes_read)
{
    if (!buffer || !bytes_read)
    {
        return ESP_ERR_INVALID_ARG;
    }
    
    // Read PC microphone samples from circular buffer
    const size_t samples_to_read = 256; // Same as real driver buffer
    
    for (size_t i = 0; i < samples_to_read; i++)
    {
        // Read 16-bit sample from PC microphone and convert to 32-bit I2S format
        int16_t pc_sample = buffer_read_sample();
        int32_t i2s_sample = ((int32_t)pc_sample) << 16; // Convert 16-bit to 32-bit I2S
        buffer[i] = i2s_sample;
    }
    
    *bytes_read = samples_to_read * sizeof(int32_t);
    
    ESP_LOGV(TAG, "Provided %zu PC microphone samples to application", samples_to_read);
    return ESP_OK;
}

esp_err_t i2s_debug_driver_set_pattern(const char *pattern)
{
    if (!pattern)
    {
        return ESP_ERR_INVALID_ARG;
    }
    
    strncpy(current_pattern, pattern, sizeof(current_pattern) - 1);
    current_pattern[sizeof(current_pattern) - 1] = '\0';
    
    ESP_LOGI(TAG, "Microphone simulation pattern set to: %s", current_pattern);
    return ESP_OK;
}

esp_err_t i2s_debug_driver_set_level(uint8_t level)
{
    audio_level = (level > 100) ? 100 : level;
    ESP_LOGI(TAG, "Microphone simulation level set to: %d%%", audio_level);
    return ESP_OK;
}

// Additional API functions to match i2s_generic_driver interface
esp_err_t i2s_debug_driver_get_sample_rate(uint32_t *rate)
{
    if (!rate) return ESP_ERR_INVALID_ARG;
    *rate = 16000;
    return ESP_OK;
}

esp_err_t i2s_debug_driver_is_dma_active(bool *active)
{
    if (!active) return ESP_ERR_INVALID_ARG;
    *active = dma_simulated_active;
    return ESP_OK;
}