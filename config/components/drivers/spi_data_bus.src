// spi_data_bus component implementation
// ESP32 general purpose SPI bus for full-duplex data transfer

#include "esp_log.h"
#include "esp_system.h"
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp32_s3_r8n16_pin_assignments.h"
#include "components/spi_data_bus.hdr"
#include <stddef.h>

static const char *TAG_spi_data_bus = "spi_data_bus";

static constexpr size_t SPI_DATA_SLOT_COUNT = 32U;
static spi_data_pinset_t spi_data_slots[SPI_DATA_SLOT_COUNT];
spi_data_pinset_t cur_spi_data_pin;

// Helper function to get the next available pin from the pool
static int get_next_assignable(const int *assignable, size_t assignable_count) {
    for (size_t i = 0; i < assignable_count; ++i) {
        const int candidate = assignable[i];
        bool already_claimed = false;
        for (size_t j = 0; j < assigned_pins_count; ++j) {
            if (assigned_pins[j] == candidate) {
                already_claimed = true;
                break;
            }
        }

        if (!already_claimed) {
            if (assigned_pins_count >= (sizeof(assigned_pins) / sizeof(assigned_pins[0]))) {
                ESP_LOGE(TAG_spi_data_bus, "Assigned pin buffer exhausted");
                esp_system_abort("Assigned pin buffer exhausted");
            }

            assigned_pins[assigned_pins_count++] = candidate;
            return candidate;
        }
    }

    ESP_LOGE(TAG_spi_data_bus, "No assignable pins remain for SPI data bus");
    esp_system_abort("SPI data bus ran out of assignable pins");
    return -1;
}


esp_err_t spi_data_bus_init(void) {
    static size_t device_count = 0;

    if (device_count >= SPI_DATA_SLOT_COUNT) 
    {
        ESP_LOGE(TAG_spi_data_bus, "No remaining SPI data device slots available");
        return ESP_FAIL;
    }

    // On the very first call, allocate shared pins and initialize the bus
    if (device_count == 0) 
    {
        spi_data_slots[0].mosi = get_next_assignable(spi_assignable, spi_assignable_count);
        spi_data_slots[0].miso = get_next_assignable(spi_assignable, spi_assignable_count);
        spi_data_slots[0].sclk = get_next_assignable(spi_assignable, spi_assignable_count);

        spi_bus_config_t bus_cfg = {
            .mosi_io_num = spi_data_slots[0].mosi,
            .miso_io_num = spi_data_slots[0].miso,
            .sclk_io_num = spi_data_slots[0].clk,
            .quadwp_io_num = -1,
            .quadhd_io_num = -1,
            .max_transfer_sz = 4096, // General purpose buffer size
        };

        const esp_err_t ret = spi_bus_initialize(SPI3_HOST, &bus_cfg, SPI_DMA_CH_AUTO);
        if (ret != ESP_OK) 
        {
            ESP_LOGE(TAG_spi_data_bus, "spi_bus_initialize failed: %s", esp_err_to_name(ret));
            return ret;
        }

        ESP_LOGI(TAG_spi_data_bus,
                 "Shared SPI data pins assigned MOSI:%d MISO:%d CLK:%d",
                 spi_data_slots[0].mosi,
                 spi_data_slots[0].miso,
                 spi_data_slots[0].sclk);
    }

    // For subsequent devices, copy the shared pin configuration from the first device
    if (device_count > 0)
    {
        spi_data_slots[device_count].mosi = spi_data_slots[0].mosi;
        spi_data_slots[device_count].miso = spi_data_slots[0].miso;
        spi_data_slots[device_count].sclk = spi_data_slots[0].sclk;
    }

    // For every device (including the first), allocate its unique CS pin
    spi_data_slots[device_count].cs = get_next_assignable(spi_assignable, spi_assignable_count);
    spi_data_slots[device_count].device_handle = nullptr;

    ESP_LOGI(TAG_spi_data_bus,
             "Data slot %u assigned unique pin CS:%d",
             static_cast<unsigned>(device_count),
             spi_data_slots[device_count].cs);

    device_count++;
    return ESP_OK;
}

void spi_data_bus_act(void)
{
    static int device = 0;

    // If the current device slot is uninitialized, reset to the first device.
    // This handles both the end-of-list and the empty-list cases.
    if (device >= SPI_DATA_SLOT_COUNT || spi_data_slots[device].cs == -1)
    {
        device = 0;
    }

    // If the first slot is also uninitialized, there's nothing to do.
    if (spi_data_slots[device].cs == -1)
    {
        return;
    }

    // Set the current global pinset for other components to use
    cur_spi_data_pin = spi_data_slots[device];

#ifdef DEBUG
    cur_spi_data_pin.print();
#endif

    // Move to the next device for the next call
    device++;
}



