// spi_display_bus driver implementation
// Provides dedicated SPI bus allocation for display peripherals

#include "esp_log.h"
#include "esp_system.h"
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp32_s3_r8n16_pin_assignments.h"
#include "components/spi_display_bus.hdr"

#include <stddef.h>
#include <stdio.h>

static constexpr size_t SPI_DISPLAY_SLOT_COUNT = 32U;
static spi_display_pinset_t spi_display_slots[SPI_DISPLAY_SLOT_COUNT];
spi_display_pinset_t cur_spi_pin;

static const char *TAG_spi_display_bus = "spi_display_bus";

static spi_display_pinset_t shared_display_pins;

static int get_next_assignable(const int *assignable, size_t assignable_count) {
    for (size_t i = 0; i < assignable_count; ++i) {
        const int candidate = assignable[i];
        bool already_claimed = false;
        for (size_t j = 0; j < assigned_pins_count; ++j) {
            if (assigned_pins[j] == candidate) {
                already_claimed = true;
                break;
            }
        }

        if (!already_claimed) {
            if (assigned_pins_count >= (sizeof(assigned_pins) / sizeof(assigned_pins[0]))) {
                ESP_LOGE(TAG_spi_display_bus, "Assigned pin buffer exhausted");
                esp_system_abort("Assigned pin buffer exhausted");
            }

            assigned_pins[assigned_pins_count++] = candidate;
            return candidate;
        }
    }

    ESP_LOGE(TAG_spi_display_bus, "No assignable pins remain for SPI display bus");
    esp_system_abort("SPI display bus ran out of assignable pins");
    return -1;
}

esp_err_t spi_display_bus_init(void) {
    static size_t device_count = 0;

    if (device_count >= SPI_DISPLAY_SLOT_COUNT) 
    {
        ESP_LOGE(TAG_spi_display_bus, "No remaining SPI display device slots available");
        return ESP_FAIL;
    }

    // On the very first call, allocate shared pins and initialize the bus
    if (device_count == 0) 
    {
        spi_display_slots[0].mosi = get_next_assignable(spi_assignable, spi_assignable_count);
        spi_display_slots[0].clk = get_next_assignable(spi_assignable, spi_assignable_count);
        spi_display_slots[0].rst = get_next_assignable(spi_assignable, spi_assignable_count);

        spi_bus_config_t bus_cfg = {
            .mosi_io_num = spi_display_slots[0].mosi,
            .miso_io_num = -1,
            .sclk_io_num = spi_display_slots[0].clk,
            .quadwp_io_num = -1,
            .quadhd_io_num = -1,
            .max_transfer_sz = 240 * 240 * 2 + 8,
            .flags = SPICOMMON_BUSFLAG_MASTER,
            .intr_flags = 0
        };

        const esp_err_t ret = spi_bus_initialize(SPI2_HOST, &bus_cfg, SPI_DMA_CH_AUTO);
        if (ret != ESP_OK) 
        {
            ESP_LOGE(TAG_spi_display_bus, "spi_bus_initialize failed: %s", esp_err_to_name(ret));
            return ret;
        }

        ESP_LOGI(TAG_spi_display_bus,
                 "Shared SPI display pins assigned MOSI:%d CLK:%d RST:%d",
                 spi_display_slots[0].mosi,
                 spi_display_slots[0].clk,
                 spi_display_slots[0].rst);
    }

    // For subsequent devices, copy the shared pin configuration from the first device
    if (device_count > 0)
    {
        spi_display_slots[device_count].mosi = spi_display_slots[0].mosi;
        spi_display_slots[device_count].clk = spi_display_slots[0].clk;
        spi_display_slots[device_count].rst = spi_display_slots[0].rst;
    }

    // For every device (including the first), allocate its unique pins and add to bus
    spi_display_slots[device_count].cs = get_next_assignable(spi_assignable, spi_assignable_count);
    spi_display_slots[device_count].dc = get_next_assignable(spi_assignable, spi_assignable_count);
    spi_display_slots[device_count].bl = get_next_assignable(spi_assignable, spi_assignable_count);
    
    // Configure RST, DC, and BL as outputs
    gpio_config_t io_conf = {};
    io_conf.mode = GPIO_MODE_OUTPUT;
    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
    io_conf.pull_up_en = GPIO_PULLUP_DISABLE;
    io_conf.intr_type = GPIO_INTR_DISABLE;
    
    if (spi_display_slots[device_count].rst != -1) {
        io_conf.pin_bit_mask = (1ULL << spi_display_slots[device_count].rst);
        gpio_config(&io_conf);
        gpio_set_level((gpio_num_t)spi_display_slots[device_count].rst, 1);  // Set high initially
    }
    
    if (spi_display_slots[device_count].dc != -1) {
        io_conf.pin_bit_mask = (1ULL << spi_display_slots[device_count].dc);
        gpio_config(&io_conf);
    }
    
    if (spi_display_slots[device_count].bl != -1) {
        io_conf.pin_bit_mask = (1ULL << spi_display_slots[device_count].bl);
        gpio_config(&io_conf);
        gpio_set_level((gpio_num_t)spi_display_slots[device_count].bl, 1);  // Turn on backlight
    }
    
    spi_device_interface_config_t dev_cfg = {
        .command_bits = 0,
        .address_bits = 0,
        .dummy_bits = 0,
        .mode = 0,
        .duty_cycle_pos = 0,
        .cs_ena_pretrans = 0,
        .cs_ena_posttrans = 0,
        .clock_speed_hz = 40 * 1000 * 1000, // 40 MHz
        .input_delay_ns = 0,
        .spics_io_num = spi_display_slots[device_count].cs,
        .queue_size = 7,
        .pre_cb = NULL, // Set D/C line high for data
        .post_cb = NULL
    };

    esp_err_t ret = spi_bus_add_device(SPI2_HOST, &dev_cfg, &spi_display_slots[device_count].handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG_spi_display_bus, "spi_bus_add_device failed for CS=%d: %s", spi_display_slots[device_count].cs, esp_err_to_name(ret));
        return ret;
    }

    ESP_LOGI(TAG_spi_display_bus,
             "Display slot %u assigned unique pins CS:%d DC:%d BL:%d and handle %p",
             static_cast<unsigned>(device_count),
             spi_display_slots[device_count].cs,
             spi_display_slots[device_count].dc,
             spi_display_slots[device_count].bl,
             (void*)spi_display_slots[device_count].handle);

    // Set cur_spi_pin to the device we just created so the next component can use it immediately
    cur_spi_pin = spi_display_slots[device_count];

    device_count++;
    return ESP_OK;
}

void spi_display_bus_act(void) 
{
    static int device = 0;

    // If the current device slot is uninitialized, reset to the first device.
    // This handles both the end-of-list and the empty-list cases.
    if (device >= SPI_DISPLAY_SLOT_COUNT || spi_display_slots[device].cs == -1) 
    {
        device = 0;
    }

    // If the first slot is also uninitialized, there's nothing to do.
    if (spi_display_slots[device].cs == -1)
    {
        return;
    }

    // Set the current global pinset for other components to use
    cur_spi_pin = spi_display_slots[device];

    // Move to the next device for the next call
    device++;
}
