// spi_bus component implementation
// ESP32 VSPI bus interface for SPI communication

#include "esp_log.h"
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp32_s3_r8n16_pin_assignments.h"

static const char *TAG_spi_bus = "spi_bus";

// SPI bus pins - assigned dynamically at runtime
static int spi_mosi_pin = -1;
static int spi_miso_pin = -1;
static int spi_clk_pin = -1;

static bool spi_initialized = false;

esp_err_t spi_bus_init(void) {
    ESP_LOGI(TAG_spi_bus, "Initializing ESP32 VSPI bus with dynamic pin assignment...");

    if (spi_initialized) {
        ESP_LOGW(TAG_spi_bus, "SPI bus already initialized");
        return ESP_OK;
    }

    // Assign SPI pins dynamically from assignable arrays
    // Find available MOSI pin
    spi_mosi_pin = -1;
    for (size_t i = 0; i < spi_assignable_count; i++) {
        int pin = spi_assignable[i];
        bool already_assigned = false;
        for (size_t j = 0; j < assigned_pins_count; j++) {
            if (assigned_pins[j] == pin) {
                already_assigned = true;
                break;
            }
        }
        if (!already_assigned && assigned_pins_count < sizeof(assigned_pins)/sizeof(assigned_pins[0])) {
            assigned_pins[assigned_pins_count++] = pin;
            spi_mosi_pin = pin;
            break;
        }
    }
    if (spi_mosi_pin == -1) {
        ESP_LOGE(TAG_spi_bus, "Failed to assign SPI MOSI pin!");
        return ESP_FAIL;
    }

    // Find available MISO pin
    spi_miso_pin = -1;
    for (size_t i = 0; i < spi_assignable_count; i++) {
        int pin = spi_assignable[i];
        bool already_assigned = false;
        for (size_t j = 0; j < assigned_pins_count; j++) {
            if (assigned_pins[j] == pin) {
                already_assigned = true;
                break;
            }
        }
        if (!already_assigned && assigned_pins_count < sizeof(assigned_pins)/sizeof(assigned_pins[0])) {
            assigned_pins[assigned_pins_count++] = pin;
            spi_miso_pin = pin;
            break;
        }
    }
    if (spi_miso_pin == -1) {
        ESP_LOGE(TAG_spi_bus, "Failed to assign SPI MISO pin!");
        return ESP_FAIL;
    }

    // Find available CLK pin
    spi_clk_pin = -1;
    for (size_t i = 0; i < spi_assignable_count; i++) {
        int pin = spi_assignable[i];
        bool already_assigned = false;
        for (size_t j = 0; j < assigned_pins_count; j++) {
            if (assigned_pins[j] == pin) {
                already_assigned = true;
                break;
            }
        }
        if (!already_assigned && assigned_pins_count < sizeof(assigned_pins)/sizeof(assigned_pins[0])) {
            assigned_pins[assigned_pins_count++] = pin;
            spi_clk_pin = pin;
            break;
        }
    }
    if (spi_clk_pin == -1) {
        ESP_LOGE(TAG_spi_bus, "Failed to assign SPI CLK pin!");
        return ESP_FAIL;
    }

    ESP_LOGI(TAG_spi_bus, "Assigned SPI pins - MOSI:%d, MISO:%d, CLK:%d",
             spi_mosi_pin, spi_miso_pin, spi_clk_pin);

    // Configure SPI bus with dynamically assigned pins
    spi_bus_config_t buscfg = {
        .mosi_io_num = spi_mosi_pin,
        .miso_io_num = spi_miso_pin,
        .sclk_io_num = spi_clk_pin,
        .quadwp_io_num = -1,  // Not used
        .quadhd_io_num = -1,  // Not used
        .max_transfer_sz = 240 * 240 * 2 + 8,  // Support display transfers
    };

    esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG_spi_bus, "Failed to initialize SPI bus: %s", esp_err_to_name(ret));
        return ret;
    }

    spi_initialized = true;
    ESP_LOGI(TAG_spi_bus, "SPI bus initialized successfully (MOSI:%d, MISO:%d, CLK:%d)",
             spi_mosi_pin, spi_miso_pin, spi_clk_pin);

    return ESP_OK;
}

void spi_bus_act(void) {
    // SPI bus is passive - no action needed
    // ESP_LOGD(TAG_spi_bus, "SPI bus act");
}



