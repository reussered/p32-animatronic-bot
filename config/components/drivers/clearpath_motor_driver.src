#include "driver/gpio.h"
#include "driver/ledc.h"
#include "esp_log.h"
#include "clearpath_motor_driver.hdr"

static const char* TAG = "clearpath_driver";

// Maximum supported motors
#define MAX_MOTORS 8

// Motor states
static clearpath_state_t motor_states[MAX_MOTORS] = {0};

// LEDC channel assignments for step pulse generation
static const ledc_channel_t step_channels[MAX_MOTORS] = {
    LEDC_CHANNEL_0,
    LEDC_CHANNEL_1,
    LEDC_CHANNEL_2,
    LEDC_CHANNEL_3,
    LEDC_CHANNEL_4,
    LEDC_CHANNEL_5,
    LEDC_CHANNEL_6,
    LEDC_CHANNEL_7
};

esp_err_t clearpath_motor_driver_init(void)
{
    // Configure LEDC timer for step pulse generation
    ledc_timer_config_t timer_conf = {
        .speed_mode = LEDC_HIGH_SPEED_MODE,
        .timer_num = LEDC_TIMER_0,
        .duty_resolution = LEDC_TIMER_10_BIT,
        .freq_hz = 2000000,  // 2MHz maximum step rate
        .clk_cfg = LEDC_AUTO_CLK
    };
    
    ESP_ERROR_CHECK(ledc_timer_config(&timer_conf));
    
    ESP_LOGI(TAG, "ClearPath motor driver initialized");
    return ESP_OK;
}

void clearpath_motor_driver_act(void)
{
    // Process updates for all active motors
    for (int i = 0; i < MAX_MOTORS; i++) {
        if (motor_states[i].initialized && motor_states[i].enabled) {
            // Update motor position/speed here
            // This runs in the component dispatch system timing
        }
    }
}

esp_err_t clearpath_init_motor(uint8_t motor_id, const clearpath_config_t* config)
{
    if (motor_id >= MAX_MOTORS || !config) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // Configure GPIO pins
    gpio_config_t io_conf = {
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE
    };
    
    // Configure direction pin
    io_conf.pin_bit_mask = (1ULL << config->dir_pin);
    ESP_ERROR_CHECK(gpio_config(&io_conf));
    
    // Configure enable pin
    io_conf.pin_bit_mask = (1ULL << config->enable_pin);
    ESP_ERROR_CHECK(gpio_config(&io_conf));
    
    // Configure LEDC channel for step pin
    ledc_channel_config_t chan_conf = {
        .channel = step_channels[motor_id],
        .duty = 0,
        .gpio_num = config->step_pin,
        .speed_mode = LEDC_HIGH_SPEED_MODE,
        .hpoint = 0,
        .timer_sel = LEDC_TIMER_0
    };
    
    ESP_ERROR_CHECK(ledc_channel_config(&chan_conf));
    
    // Store configuration
    motor_states[motor_id].config = *config;
    motor_states[motor_id].initialized = true;
    motor_states[motor_id].enabled = false;
    motor_states[motor_id].current_position = 0;
    motor_states[motor_id].current_speed = 0;
    
    ESP_LOGI(TAG, "Motor %d initialized on pins: step=%d, dir=%d, enable=%d",
             motor_id, config->step_pin, config->dir_pin, config->enable_pin);
             
    return ESP_OK;
}

esp_err_t clearpath_enable_motor(uint8_t motor_id)
{
    if (motor_id >= MAX_MOTORS || !motor_states[motor_id].initialized) {
        return ESP_ERR_INVALID_ARG;
    }
    
    gpio_set_level(motor_states[motor_id].config.enable_pin, 1);
    motor_states[motor_id].enabled = true;
    
    ESP_LOGI(TAG, "Motor %d enabled", motor_id);
    return ESP_OK;
}

esp_err_t clearpath_disable_motor(uint8_t motor_id)
{
    if (motor_id >= MAX_MOTORS || !motor_states[motor_id].initialized) {
        return ESP_ERR_INVALID_ARG;
    }
    
    gpio_set_level(motor_states[motor_id].config.enable_pin, 0);
    motor_states[motor_id].enabled = false;
    
    ESP_LOGI(TAG, "Motor %d disabled", motor_id);
    return ESP_OK;
}

esp_err_t clearpath_move_to_position(uint8_t motor_id, int32_t position, uint32_t speed)
{
    if (motor_id >= MAX_MOTORS || !motor_states[motor_id].initialized || !motor_states[motor_id].enabled) {
        return ESP_ERR_INVALID_ARG;
    }
    
    clearpath_state_t* motor = &motor_states[motor_id];
    
    // Set direction
    bool direction = position > motor->current_position;
    gpio_set_level(motor->config.dir_pin, direction);
    
    // Calculate number of steps
    uint32_t steps = abs(position - motor->current_position);
    
    // Configure step pulse frequency (speed)
    uint32_t freq = min(speed, motor->config.max_speed);
    ESP_ERROR_CHECK(ledc_set_freq(LEDC_HIGH_SPEED_MODE, LEDC_TIMER_0, freq));
    
    // Start step pulses with 50% duty cycle
    ESP_ERROR_CHECK(ledc_set_duty(LEDC_HIGH_SPEED_MODE, step_channels[motor_id], 512));
    ESP_ERROR_CHECK(ledc_update_duty(LEDC_HIGH_SPEED_MODE, step_channels[motor_id]));
    
    motor->current_position = position;
    motor->current_speed = freq;
    
    ESP_LOGI(TAG, "Motor %d moving to position %ld at %lu steps/sec", 
             motor_id, position, freq);
             
    return ESP_OK;
}

esp_err_t clearpath_stop_motor(uint8_t motor_id)
{
    if (motor_id >= MAX_MOTORS || !motor_states[motor_id].initialized) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // Stop step pulses
    ESP_ERROR_CHECK(ledc_set_duty(LEDC_HIGH_SPEED_MODE, step_channels[motor_id], 0));
    ESP_ERROR_CHECK(ledc_update_duty(LEDC_HIGH_SPEED_MODE, step_channels[motor_id]));
    
    motor_states[motor_id].current_speed = 0;
    
    ESP_LOGI(TAG, "Motor %d stopped", motor_id);
    return ESP_OK;
}

esp_err_t clearpath_emergency_stop(uint8_t motor_id)
{
    if (motor_id >= MAX_MOTORS || !motor_states[motor_id].initialized) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // Immediately disable motor and stop pulses
    gpio_set_level(motor_states[motor_id].config.enable_pin, 0);
    ESP_ERROR_CHECK(ledc_set_duty(LEDC_HIGH_SPEED_MODE, step_channels[motor_id], 0));
    ESP_ERROR_CHECK(ledc_update_duty(LEDC_HIGH_SPEED_MODE, step_channels[motor_id]));
    
    motor_states[motor_id].enabled = false;
    motor_states[motor_id].current_speed = 0;
    
    ESP_LOGW(TAG, "Motor %d emergency stop triggered", motor_id);
    return ESP_OK;
}