// goblin_eye_mood_processor.src - Lightweight mood processor for scanlines (no hardware)
#include "esp_log.h"
#include "config/components/hardware/gc9a01.hdr"  // For Pixel type
#include "Mood.hpp"
#include "core/memory/SharedMemory.hpp"

// Cached mood tint - updated when mood changes
static Pixel cachedMoodTint = {0, 0, 0};
static uint32_t lastMoodChecksum = 0;

esp_err_t goblin_eye_mood_processor_init(void)
{
    ESP_LOGI("goblin_eye_mood_processor", "Initializing mood processor (lightweight, no hardware)");
    cachedMoodTint = {0, 0, 0};
    lastMoodChecksum = 0;
    return ESP_OK;
}

void goblin_eye_mood_processor_act(void)
{
    // Get current mood from SharedMemory
    Mood* mood = GSM.read<Mood>();
    if (!mood)
    {
        return;
    }

    // Calculate mood checksum to detect changes
    uint32_t currentChecksum = (uint32_t)(mood->anger * 1000) + 
                               (uint32_t)(mood->curiosity * 100) + 
                               (uint32_t)(mood->fear * 10) + 
                               (uint32_t)(mood->happiness);

    // Recalculate tint only if mood changed
    if (currentChecksum != lastMoodChecksum)
    {
        lastMoodChecksum = currentChecksum;

        // Calculate mood-based color tint (emotion intensity: 1.5x multiplier)
        float intensityMult = 1.5f;
        cachedMoodTint.r = (uint8_t)(mood->anger * 255.0f * intensityMult);
        cachedMoodTint.g = (uint8_t)(mood->curiosity * 255.0f * 1.2f);  // Slight green for curiosity
        cachedMoodTint.b = (uint8_t)(mood->fear * 255.0f * 1.3f);       // Blue for fear

        // Add happiness as yellow (red + green)
        uint8_t happiness_tint = (uint8_t)(mood->happiness * 180.0f * 1.4f);
        cachedMoodTint.r = (uint8_t)((cachedMoodTint.r + happiness_tint) > 255 ? 255 : cachedMoodTint.r + happiness_tint);
        cachedMoodTint.g = (uint8_t)((cachedMoodTint.g + happiness_tint) > 255 ? 255 : cachedMoodTint.g + happiness_tint);
    }

    // Apply cached mood tint to current scanline (from either left or right eye)
    // This processor doesn't know which eye - it just processes whatever scanline is current
    extern Pixel* left_scanline_buffer;
    extern Pixel* right_scanline_buffer;
    extern uint16_t currentScanline;

    // Determine which eye's scanline to process based on initialization order
    // For simplicity, process both if they exist
    if (left_scanline_buffer != nullptr)
    {
        for (int x = 0; x < 240; x++)
        {
            // Saturating addition of mood tint
            left_scanline_buffer[x].r = (uint8_t)((left_scanline_buffer[x].r + cachedMoodTint.r) > 255 ? 255 : left_scanline_buffer[x].r + cachedMoodTint.r);
            left_scanline_buffer[x].g = (uint8_t)((left_scanline_buffer[x].g + cachedMoodTint.g) > 255 ? 255 : left_scanline_buffer[x].g + cachedMoodTint.g);
            left_scanline_buffer[x].b = (uint8_t)((left_scanline_buffer[x].b + cachedMoodTint.b) > 255 ? 255 : left_scanline_buffer[x].b + cachedMoodTint.b);
        }
    }

    if (right_scanline_buffer != nullptr)
    {
        for (int x = 0; x < 240; x++)
        {
            // Saturating addition of mood tint
            right_scanline_buffer[x].r = (uint8_t)((right_scanline_buffer[x].r + cachedMoodTint.r) > 255 ? 255 : right_scanline_buffer[x].r + cachedMoodTint.r);
            right_scanline_buffer[x].g = (uint8_t)((right_scanline_buffer[x].g + cachedMoodTint.g) > 255 ? 255 : right_scanline_buffer[x].g + cachedMoodTint.g);
            right_scanline_buffer[x].b = (uint8_t)((right_scanline_buffer[x].b + cachedMoodTint.b) > 255 ? 255 : right_scanline_buffer[x].b + cachedMoodTint.b);
        }
    }
}
