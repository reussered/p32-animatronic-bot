// goblin_left_eye component implementation
// TEMPLATE-BASED "ALLOCATOR"
// Allocates a display buffer based on the provided hardware type T.

#include "esp_log.h"
#include <cstdint>

// This file-scoped static pointer is the key to the new architecture.
// It is templated on the hardware type 'T'. When the build script
// generates the final C++ file, it will instantiate this variable
// with a concrete type (e.g., gc9a01), making the buffer available
// to any other component within the same compilation unit.
template <typename T>
static typename T::Pixel* display_buffer = nullptr;

template <typename T>
esp_err_t goblin_left_eye_init()
{
    const char *TAG = "goblin_left_eye";
    ESP_LOGI(TAG, "Initializing left eye display buffer (template-based)");

    // Calculate size from the hardware type T's static constants.
    const int display_size = T::WIDTH * T::HEIGHT;

    // Allocate the buffer using the nested Pixel type from T.
    display_buffer<T> = new typename T::Pixel[display_size];

    if (!display_buffer<T>)
    {
        ESP_LOGE(TAG, "Failed to allocate left eye buffer");
        return ESP_ERR_NO_MEM;
    }

    // Initialize buffer to black.
    for (int i = 0; i < display_size; i++)
    {
        display_buffer<T>[i] = typename T::Pixel(); // Default constructor is black.
    }

    ESP_LOGI(TAG, "Left eye buffer allocated: %d pixels (%.1f KB)",
             display_size, (display_size * sizeof(typename T::Pixel)) / 1024.0f);

    return ESP_OK;
}

template <typename T>
void goblin_left_eye_act()
{
    // This component is now just an allocator.
    // The 'act' function doesn't need to do anything in every cycle.
    // Other components will read from/write to the 'display_buffer'.
    // This function exists to satisfy the component model.
}





