# Topic 6: Timing and Execution

**Purpose**: Understand how components initialize once and execute repeatedly.

---

## Execution Model

Every subsystem has two dispatch tables generated by `generate_tables.py`:

```cpp
// Generated in subsystems/goblin_head/goblin_head_dispatch_tables.cpp
const init_function_t goblin_head_init_table[] = {
    &goblin_eye_init,
    &goblin_servo_init,
    &goblin_display_init
};

const act_function_t goblin_head_act_table[] = {
    &goblin_eye_act,
    &goblin_servo_act,
    &goblin_display_act
};

const uint32_t goblin_head_hitcount_table[] = {
    1,   // goblin_eye_act runs every loop
    2,   // goblin_servo_act runs every 2nd loop
    5    // goblin_display_act runs every 5th loop
};
```

---

## 1. Initialization Phase (Once at Startup)

The subsystem's `main()` calls `init_table` **once** in array order:

```cpp
// Generated subsystem main (simplified)
void app_main(void)
{
    // Initialize all components in order
    for (size_t i = 0; i < goblin_head_init_table_size; i++)
    {
        esp_err_t ret = goblin_head_init_table[i]();
        if (ret != ESP_OK)
        {
            ESP_LOGE(TAG, "Component %zu init failed: %d", i, ret);
            return;  // Fatal error, halt subsystem
        }
    }
    
    // Enter execution loop
    while (true)
    {
        execute_act_table();
        vTaskDelay(pdMS_TO_TICKS(10));  // ~100Hz loop
    }
}
```

**Key points**:
- Each `init()` executes **exactly once** at startup
- Order matches JSON component order
- Any `init()` returning non-ESP_OK halts the subsystem
- Failed init = component not available in `act()` loop

### Example: Component Initialization

```cpp
// Component A init (runs first)
esp_err_t goblin_eye_init(void)
{
    ESP_LOGI(TAG, "Initializing eyes");
    display_buffer = (uint16_t*)malloc(240 * 240 * 2);
    if (display_buffer == NULL)
    {
        return ESP_ERR_NO_MEM;  // Fatal - halt subsystem
    }
    return ESP_OK;  // Success - proceed to next component
}

// Component B init (runs second, depends on Component A)
esp_err_t goblin_display_init(void)
{
    ESP_LOGI(TAG, "Initializing display driver");
    if (display_buffer == NULL)
    {
        ESP_LOGE(TAG, "Display buffer not allocated");
        return ESP_FAIL;  // Component A failed - halt
    }
    
    esp_err_t ret = spi_bus_initialize(/* ... */);
    return ret;  // Propagate SPI init result
}
```

---

## 2. Execution Loop (Continuous)

After all `init()` succeed, the main loop calls `act_table` repeatedly:

```cpp
// Simplified execution loop
static uint32_t loop_counter = 0;

void execute_act_table(void)
{
    loop_counter++;
    
    for (size_t i = 0; i < goblin_head_act_table_size; i++)
    {
        uint32_t hitcount = goblin_head_hitcount_table[i];
        
        // Execute only if loop_counter is multiple of hitcount
        if (loop_counter % hitcount == 0)
        {
            goblin_head_act_table[i]();  // Call component's act()
        }
    }
}
```

### Hit Count Mechanics

`hitCount` from JSON controls execution frequency:

| `hitCount` | Frequency | Use Case |
|------------|-----------|----------|
| 1 | Every loop (~100Hz) | Critical sensors, fast rendering |
| 2 | Every 2nd loop (~50Hz) | Servo updates, LED patterns |
| 5 | Every 5th loop (~20Hz) | Behavior logic, mood updates |
| 10 | Every 10th loop (~10Hz) | Slow sensors, diagnostics |
| 100 | Every 100th loop (~1Hz) | Status reporting, cleanup |

### Example: Mixed Frequency Components

```json
// In goblin_head.json components array
[
  {
    "component": "goblin_eye_renderer",
    "timing": { "hitCount": 1 }  // 100Hz - smooth animation
  },
  {
    "component": "goblin_servo",
    "timing": { "hitCount": 2 }  // 50Hz - servo control
  },
  {
    "component": "goblin_behavior",
    "timing": { "hitCount": 10 }  // 10Hz - decision making
  }
]
```

**Execution timeline** (first 10 loops):

```
Loop 1:  eye_renderer, servo, behavior  (all hit)
Loop 2:  eye_renderer, servo            (hitCount 1,2)
Loop 3:  eye_renderer                   (hitCount 1)
Loop 4:  eye_renderer, servo            (hitCount 1,2)
Loop 5:  eye_renderer                   (hitCount 1)
Loop 6:  eye_renderer, servo            (hitCount 1,2)
Loop 7:  eye_renderer                   (hitCount 1)
Loop 8:  eye_renderer, servo            (hitCount 1,2)
Loop 9:  eye_renderer                   (hitCount 1)
Loop 10: eye_renderer, servo, behavior  (all hit)
```

---

## 3. Component Patterns

### Fast Component (hitCount: 1)

```cpp
// Runs every loop - must be lightweight
void goblin_eye_renderer_act(void)
{
    // Update animation frame
    static uint32_t frame_index = 0;
    render_frame(display_buffer, frame_index++);
    
    // Keep under 1ms execution time for 100Hz loop
}
```

### Slow Component (hitCount: 10+)

```cpp
// Runs every 10th loop - can do heavier work
void goblin_behavior_act(void)
{
    Mood mood = GSM.read<Mood>();
    Environment env = GSM.read<Environment>();
    
    // Complex decision tree (10ms budget acceptable)
    if (env.proximity_cm < 30)
    {
        mood.curiosity = calculate_curiosity_level();
        GSM.write(mood);
    }
}
```

### Adaptive Timing

```cpp
// Component adjusts own execution frequency
static uint32_t skip_counter = 0;
static uint32_t current_skip = 1;  // Dynamic hitCount

void goblin_sensor_act(void)
{
    skip_counter++;
    if (skip_counter < current_skip)
    {
        return;  // Skip this iteration
    }
    skip_counter = 0;
    
    // Actual work
    uint32_t proximity = read_ultrasonic();
    
    // If object close, sample faster
    current_skip = (proximity < 50) ? 1 : 5;
}
```

---

## 4. Execution Order

Components execute in **JSON order** within each loop iteration:

```json
// Order matters for data flow
[
  {
    "component": "sensor_reader",  // Reads hardware
    "timing": { "hitCount": 1 }
  },
  {
    "component": "data_processor",  // Processes sensor data
    "timing": { "hitCount": 1 }
  },
  {
    "component": "display_updater",  // Shows processed data
    "timing": { "hitCount": 1 }
  }
]
```

Execution flow:
```
Loop N:
  1. sensor_reader_act()     → writes to file-scoped buffer
  2. data_processor_act()    → reads buffer, writes results
  3. display_updater_act()   → reads results, updates display
```

**Critical**: If `display_updater` runs before `sensor_reader`, it sees **previous loop's data**.

---

## 5. Timing Constraints

### Loop Budget

Target: 10ms per loop (100Hz)

```cpp
// ✓ DO (fast enough for hitCount: 1)
void act(void)
{
    memcpy(display_buffer, frame_data, buffer_size);  // <1ms
}

// ✗ DON'T (blocks entire loop)
void act(void)
{
    vTaskDelay(pdMS_TO_TICKS(50));  // 50ms - destroys loop timing
}

// ✓ DO (use state machine for delays)
void act(void)
{
    static uint64_t next_action_us = 0;
    uint64_t now_us = esp_timer_get_time();
    
    if (now_us < next_action_us)
    {
        return;  // Not time yet
    }
    
    perform_action();
    next_action_us = now_us + 50000;  // 50ms from now
}
```

### Execution Time Measurement

```cpp
void goblin_heavy_act(void)
{
    uint64_t start_us = esp_timer_get_time();
    
    // Component work
    perform_complex_calculation();
    
    uint64_t elapsed_us = esp_timer_get_time() - start_us;
    if (elapsed_us > 5000)  // Warn if >5ms
    {
        ESP_LOGW(TAG, "Slow act(): %llu us", elapsed_us);
    }
}
```

---

## 6. Common Mistakes

| Mistake | Symptom | Fix |
|---------|---------|-----|
| `vTaskDelay()` in `act()` | Loop freezes | Use state machine with timer checks |
| Ignoring `hitCount` | Component too slow | Increase `hitCount` or optimize |
| Heavy work at `hitCount: 1` | Loop lag, jitter | Move to higher `hitCount` or split work |
| Expecting instant sync | Race conditions | Check state before use |
| Order-dependent components wrong sequence | Stale data, glitches | Reorder in JSON |

---

## 7. init() vs act() Decision Chart

```
Needs to happen:
├─ Once at startup?
│  └─ Put in component_init()
│     Examples:
│     - Allocate buffers
│     - Initialize hardware
│     - Set default state
│     - Register handlers
│
└─ Every loop (or periodically)?
   └─ Put in component_act()
      Examples:
      - Read sensors
      - Update displays
      - Process inputs
      - Send network packets
```

---

## 8. Example: Complete Component

```cpp
// File-scoped state
static uint16_t* frame_buffer = NULL;
static uint32_t frame_index = 0;

// Init: Allocate resources (once)
esp_err_t goblin_eye_init(void)
{
    frame_buffer = (uint16_t*)malloc(240 * 240 * 2);
    if (frame_buffer == NULL)
    {
        ESP_LOGE(TAG, "Failed to allocate frame buffer");
        return ESP_ERR_NO_MEM;
    }
    
    ESP_LOGI(TAG, "Eye component initialized");
    return ESP_OK;
}

// Act: Update animation (every loop)
void goblin_eye_act(void)
{
    if (frame_buffer == NULL)
    {
        return;  // Init failed, skip
    }
    
    // Read mood from GSM
    Mood mood = GSM.read<Mood>();
    
    // Render frame based on mood
    if (mood.happiness > 50)
    {
        render_happy_eyes(frame_buffer, frame_index);
    }
    else
    {
        render_neutral_eyes(frame_buffer, frame_index);
    }
    
    frame_index++;
}
```

With `"timing": { "hitCount": 1 }` in JSON:
- `goblin_eye_init()` runs **once** at startup
- `goblin_eye_act()` runs **every loop** (~100Hz)

With `"timing": { "hitCount": 5 }`:
- `goblin_eye_init()` still runs **once** at startup
- `goblin_eye_act()` runs **every 5th loop** (~20Hz)

---

**Token count**: ~1,600
