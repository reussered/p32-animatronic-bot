# Consistent Project Rules

This file contains the up-to-date, consistent rules for the p32-animatronic-bot project. All agents and contributors must read and apply these rules before performing any task.

1. All component functions must use NO ARGUMENTS
2. The JSON file that defines each component must have a software subsection with both init_function and act_function fields. Each field must be present: if the function is not needed, its value must be "STUB"; otherwise, the value is the exact name of the function. Remove all references to the hardware_only flag.
    for example:
        software :
        {
            init_function: {component_id}_init
            act_function: S
        }
3. **HARDWARE-ONLY COMPONENTS**: When both init_function and act_function are set to "STUB", this indicates a hardware-only component (replaces the old hardware_only flag). These components provide only physical mounting/shape definitions and generate no executable code.
4. **COMPONENT NAMING**: All filenames and function names are derived from `component_name`. The `component_name` serves as both the human-readable identifier and the technical identifier used for code generation. Component names must be valid C++ identifiers (no spaces, special characters). **BILATERAL COMPONENT NAMING**: For paired/sided components, use the pattern `{creature}_{side}_{component}` (e.g., `goblin_left_eye`, `goblin_right_ear`, `goblin_left_hand`). Never use `{creature}_{component}_{side}` pattern.
5. **RECURSIVE COMPONENT COMPOSITION**: Use `contained_components` array for hierarchical component inclusion. This keyword lists the relative paths to JSON files of components contained within the current component, enabling single JSON file creature definitions via recursive composition. Replaces old keywords: `family_level_components`, `subsystem_assemblies`, `positioned_components`. ALL composite components (assemblies, subsystems, creatures) MUST explicitly declare their `contained_components` array - no implicit component inclusion allowed. **CREATURE MANIFEST**: Creature definitions MUST include a `subsystem_manifest` that explicitly lists all subsystems, their controllers, and all components belonging to each subsystem for complete system visibility.
6. **ESP-NOW MESH CLEANUP**: Remove all ESP-NOW mesh configuration variables from JSON files. SharedMemory class encapsulates ESP-NOW mesh internally, making these variables obsolete: `mesh_role`, `mesh_capabilities`, `ESP_NOW_MASTER`, `ESP_NOW_SLAVE`, `SLAVE_NODE_HIGH_PRIORITY`, `mesh_network_config`, `esp_now_channel`, `mesh_node_count`, `mesh_heartbeat_hitCount`, `esp_now_enabled`. Components use SharedMemory.read()/write() for inter-ESP32 communication without explicit mesh configuration.
7. All rules in this file supersede conflicting rules elsewhere in the documentation.
8. If a rule is unclear or inconsistent, report it immediately and halt further action until resolved.
9. The agent must always check this file first before executing any project-related task.
10. **DISPATCH TABLE GENERATION**: All dispatch table generation must follow the rules in `docs/DISPATCH-TABLE-GENERATION-RULES-SPEC.md`. The validation script MUST auto-generate exactly 4 files from JSON configurations: `src/p32_dispatch_tables.cpp`, `include/p32_dispatch_tables.hpp`, `src/p32_component_functions.cpp`, `include/p32_component_functions.hpp`. All 4 files MUST be in .gitignore as auto-generated content.
11. **MULTI-ESP32 ARCHITECTURE**: All component-to-controller assignment and code generation MUST follow the architecture defined in `docs/MULTI-ESP32-COMPONENT-ARCHITECTURE-SPEC.md`. Components belong to exactly ONE subsystem/controller. Use `controller` keyword to define subsystem boundaries. Per-component files (1:1) and per-subsystem files (many:1) generated separately.
12. **THREE-LEVEL COMPONENT HIERARCHY WITH POSITION AND SHAPE**: All components MUST follow the three-level hierarchy pattern: `{Creature}_{side}_{part}` components contain `{Creature}_{part}` components which contain `{part}` components. Each level serves a specific purpose: spatial level (coordinates via `position` keyword, bilateral differentiation), creature level (species-specific behavior, software-only), hardware level (device drivers with physical mounting). Component classification: components WITH `position` keyword are placed at specific coordinates; components WITH `shape` parameter provide physical mounting brackets; components specify only their public interface (`init_function` and `act_function`) in JSON - internal implementation functions are invisible to the component system. Examples: `goblin_left_eye` (with position) → `goblin_eye` (software-only) → `gc9a01` (init/act functions + mounting bracket shape).
13. **SUBSYSTEM ASSIGNMENT**: Every component MUST include a `subsystem` keyword that directly specifies which ESP32 controller/subsystem the component belongs to (e.g., "HEAD", "TORSO", "LEFT_ARM", "RIGHT_ARM"). This enables proper code generation and deployment to the correct ESP32 controller in the distributed multi-ESP32 architecture. For hardware components that could be used in multiple subsystems (like displays, sensors), the subsystem assignment in the hardware component JSON represents the most common usage - specific positioned components can override this assignment as needed. The dispatch table generator uses the most specific subsystem assignment found in the containment hierarchy.

(Continue adding consistent rules as they are validated.)
