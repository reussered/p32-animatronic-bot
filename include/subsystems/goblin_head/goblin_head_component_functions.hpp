#ifndef GOBLIN_HEAD_COMPONENT_FUNCTIONS_HPP
#define GOBLIN_HEAD_COMPONENT_FUNCTIONS_HPP

#include <cstddef>
#include <cstdint>
#include "esp_err.h"

// Auto-generated by tools/generate_tables.py
// Subsystem: goblin_head
// Controller: ESP32_S3_R8N16

// Component definition sourced from config\components\hardware\hw496_microphone.json
struct HW496_MICROPHONE_config {
    const char* relative_filename = "config/components/hardware/hw496_microphone.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* component_type = "MEMS_MICROPHONE";
    const char* hardware_name = "HW-496 MEMS Microphone Module";
    const char* description = "HW-496 MEMS microphone with MAX4466 pre-amplifier";
    const char* created = "2025-10-15";
    struct hardware_specs_t {
        const char* microphone_type = "electret_mems";
        const char* frequency_response = "20Hz_to_20kHz";
        const char* sensitivity = "adjustable_gain";
        const char* max_spl = "110dB_SPL";
        const char* signal_to_noise = "58dB";
    } hardware_specs;
    struct physical_properties_t {
        struct board_dimensions_t {
            const char* width = "20mm";
            const char* length = "15mm";
            const char* height = "7mm";
        } board_dimensions;
        const char* weight = "1.5g";
        struct mounting_holes_t {
            int count = 2;
            const char* diameter = "2mm";
            const char* spacing = "15mm";
        } mounting_holes;
    } physical_properties;
    struct control_interface_t {
        const char* protocol = "analog";
        const char* output_type = "analog_voltage";
        const char* output_range = "0-3.3V";
        const char* adc_connection = "single_ended";
    } control_interface;
    struct power_requirements_t {
        const char* operating_voltage = "2.4V-5V";
        const char* typical_voltage = "3.3V";
        const char* current_consumption = "4mA_typical";
        const char* max_current = "10mA";
    } power_requirements;
    struct pin_mapping_t {
        const char* pins = "[{\"name\": \"VCC\", \"type\": \"power\", \"voltage\": \"3.3V\"}, {\"name\": \"GND\", \"type\": \"ground\"}, {\"name\": \"OUT\", \"type\": \"analog_output\", \"description\": \"Audio signal output\"}]";
    } pin_mapping;
    struct gain_adjustment_t {
        const char* method = "potentiometer";
        const char* range = "25x_to_125x";
        const char* default = "50x";
    } gain_adjustment;
    const char* prototype_status = "available_on_hand";
    bool tested = false;
    int quantity_available = 2;
    const char* supplier = "Generic/AliExpress";
    const char* notes[4] = { "Physical hardware available for testing", "Requires ADC pin assignment for each ear", "Adjustable gain via onboard trimpot", "Can be used for sound detection or voice input" };
    const char* hardware_type = "MEMS_MICROPHONE";
    const char* name = "HW496_MICROPHONE";
    const char* dependencies[2] = { "config/components/drivers/adc_bus.json", "config/components/drivers/generic_mic_driver.json" };
    struct software_t {
        const char* init_function = "hw496_microphone_init";
        const char* act_function = "hw496_microphone_act";
    } software;
};

// Component definition sourced from config\components\hardware\gc9a01_display.json
struct gc9a01_config {
    const char* relative_filename = "config/components/hardware/gc9a01_display.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* hardware_type = "GC9A01_DISPLAY";
    const char* component_type = "DISPLAY_DRIVER";
    bool display_driver = true;
    const char* name = "gc9a01";
    const char* subsystem = "HEAD";
    struct physical_specs_t {
        const char* diameter = "1.28 INCH";
        const char* thickness = "0.08 INCH";
        const char* resolution = "240x240";
        struct mounting_holes_t {
            int count = 4;
            const char* diameter = "0.1 INCH";
            const char* spacing = "1.1 INCH";
        } mounting_holes;
    } physical_specs;
    struct timing_t {
        int hitCount = 1;
        const char* description = "Display updates every loop for smooth animation";
    } timing;
    struct pin_mapping_t {
        const char* description = "GC9A01 displays have varying pin labels depending on manufacturer. See MakerNames.json for complete mapping.";
        const char* manufacturer_mapping_reference = "config/components/interfaces/MakerNames.json";
        struct generic_pins_t {
            struct clock_t {
                const char* function = "SPI Clock";
                bool required = true;
                const char* manufacturer_labels[4] = { "CLK", "SCK", "SCLK", "SCL" };
            } clock;
            struct data_input_t {
                const char* function = "SPI Master Out Slave In (Data)";
                bool required = true;
                const char* manufacturer_labels[4] = { "MOSI", "SDA", "SDI", "DIN" };
            } data_input;
            struct data_command_t {
                const char* function = "Data/Command Select";
                bool required = true;
                const char* manufacturer_labels[4] = { "DC", "D/C", "RS", "A0" };
            } data_command;
            struct chip_select_t {
                const char* function = "Chip Select (Slave Select)";
                bool required = true;
                const char* manufacturer_labels[3] = { "CS", "SS", "CE" };
            } chip_select;
            struct reset_t {
                const char* function = "Hardware Reset";
                bool required = true;
                const char* manufacturer_labels[3] = { "RST", "RESET", "RES" };
            } reset;
            struct backlight_t {
                const char* function = "Backlight Control (PWM)";
                bool required = false;
                const char* manufacturer_labels[3] = { "BL", "BLK", "LED" };
            } backlight;
            struct power_positive_t {
                const char* function = "Power Supply (3.3V)";
                bool required = true;
                const char* manufacturer_labels[4] = { "VCC", "VDD", "3V3", "+3.3V" };
            } power_positive;
            struct power_ground_t {
                const char* function = "Ground Reference";
                bool required = true;
                const char* manufacturer_labels[3] = { "GND", "VSS", "0V" };
            } power_ground;
        } generic_pins;
        struct common_manufacturer_variations_t {
            struct variation_1_t {
                const char* description = "Most common pinout (your displays)";
                const char* pins_exposed[7] = { "SCK", "SDA", "DC", "CS", "RST", "VCC", "GND" };
            } variation_1;
            struct variation_2_t {
                const char* description = "Waveshare/Adafruit style";
                const char* pins_exposed[8] = { "CLK", "MOSI", "DC", "CS", "RST", "BL", "VCC", "GND" };
            } variation_2;
            struct variation_3_t {
                const char* description = "Generic Chinese modules";
                const char* pins_exposed[8] = { "SCLK", "SDI", "RS", "CS", "RESET", "LED", "VDD", "GND" };
            } variation_3;
        } common_manufacturer_variations;
    } pin_mapping;
    struct driver_config_t {
        int rotation = 0;
        bool invert_colors = false;
        bool backlight_pwm = true;
    } driver_config;
    struct color_specifications_t {
        const char* color_mode = "full_color";
        int bit_depth = 16;
        const char* color_space = "RGB565";
        int colors_supported = 65536;
        const char* description = "Full color 16-bit RGB display";
    } color_specifications;
    struct mood_color_response_t {
        bool supports_dynamic_colors = true;
        bool full_spectrum_available = true;
        struct mood_mapping_t {
            const char* ANGER = "#FF0000";
            const char* FEAR = "#800080";
            const char* HAPPINESS = "#FFFF00";
            const char* CONTENTMENT = "#00FF00";
            const char* CURIOSITY = "#0080FF";
            const char* IRRITATION = "#FF8000";
            const char* HUNGER = "#FF0080";
            const char* AFFECTION = "#FF69B4";
        } mood_mapping;
    } mood_color_response;
    struct software_t {
        const char* init_function = "gc9a01_init";
        const char* act_function = "gc9a01_act";
    } software;
    const char* required_interface_functions[3] = { "getBuffer", "getFrameSize", "getFrameRowSize" };
};

// Component definition sourced from config\components\hardware\generic_spi_display.json
struct generic_spi_display_config {
    const char* relative_filename = "config/components/hardware/generic_spi_display.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* hardware_type = "GENERIC_SPI_DISPLAY";
    const char* component_type = "DISPLAY_DRIVER";
    bool display_driver = true;
    const char* name = "generic_spi_display";
    const char* subsystem = "HEAD";
    struct physical_specs_t {
        const char* description = "Generic SPI display specifications - configured per device";
    } physical_specs;
    struct electrical_specs_t {
        const char* supply_voltage = "3.3V";
        const char* interface = "SPI";
        const char* current_consumption = "Variable";
    } electrical_specs;
    struct timing_t {
        int hitCount = 1;
        const char* description = "Generic display driver updates every loop for smooth animation";
    } timing;
    struct pin_mapping_t {
        const char* description = "Generic SPI display pins - configured by positioned components";
        struct generic_pins_t {
            struct clock_t {
                const char* function = "SPI Clock";
                bool required = true;
                const char* manufacturer_labels[4] = { "CLK", "SCK", "SCLK", "SCL" };
            } clock;
            struct data_input_t {
                const char* function = "SPI Master Out Slave In (Data)";
                bool required = true;
                const char* manufacturer_labels[4] = { "MOSI", "SDA", "SDI", "DIN" };
            } data_input;
            struct data_command_t {
                const char* function = "Data/Command Select";
                bool required = true;
                const char* manufacturer_labels[4] = { "DC", "D/C", "RS", "A0" };
            } data_command;
            struct chip_select_t {
                const char* function = "Chip Select (Slave Select)";
                bool required = true;
                const char* manufacturer_labels[3] = { "CS", "SS", "CE" };
            } chip_select;
            struct reset_t {
                const char* function = "Hardware Reset";
                bool required = true;
                const char* manufacturer_labels[3] = { "RST", "RESET", "RES" };
            } reset;
        } generic_pins;
    } pin_mapping;
    struct driver_config_t {
        int width = 240;
        int height = 240;
        int color_depth = 16;
        int rotation = 0;
        bool invert_colors = false;
        bool backlight_pwm = true;
    } driver_config;
    struct color_specifications_t {
        const char* color_mode = "full_color";
        int bit_depth = 16;
        const char* color_space = "RGB565";
        int colors_supported = 65536;
        const char* description = "Full color 16-bit RGB display";
    } color_specifications;
    struct software_t {
        const char* init_function = "generic_spi_display_init";
        const char* act_function = "generic_spi_display_act";
    } software;
    const char* required_interface_functions[4] = { "generic_display_get_buffer", "generic_display_get_frame_size", "generic_display_get_frame_width", "generic_display_get_frame_height" };
};

// Component definition sourced from config\components\creature_specific\goblin_eye.json
struct goblin_eye_config {
    const char* relative_filename = "config/components/creature_specific/goblin_eye.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "goblin_eye";
    const char* subsystem = "HEAD";
    const char* type = "CREATURE_SPECIFIC_DISPLAY";
    const char* description = "Shared goblin eye processing logic with palette and mood-based rendering";
    const char* created = "2025-10-22";
    struct component_constraints_t {
        const char* required_contained_types[1] = { "DISPLAY_DRIVER" };
        const char* interface_requirements[3] = { "getBuffer", "getFrameSize", "getFrameRowSize" };
    } component_constraints;
    struct creature_display_profile_t {
        const char* species = "GOBLIN";
        const char* eye_color_base = "AMBER_GOLD";
        const char* pupil_style = "VERTICAL_SLIT";
        const char* expression_range = "MENACING_TO_CURIOUS";
        const char* mood_responsiveness = "HIGH";
    } creature_display_profile;
    struct palette_system_t {
        int palette_size = 256;
        struct color_ranges_t {
            const char* eyelid_pupil = "0-31";
            const char* iris_base = "32-63";
            const char* highlights = "64-95";
            const char* bird_colors = "64-95";
            const char* anger_reds = "96-127";
            const char* curiosity_greens = "128-159";
            const char* fear_blues = "160-191";
            const char* happiness_yellows = "192-223";
            const char* special_effects = "224-255";
        } color_ranges;
    } palette_system;
    struct mood_color_mapping_t {
        struct ANGER_t {
            const char* primary_range = "96-127";
            float intensity_multiplier = 1.5;
            const char* glow_effect = "ENABLED";
        } ANGER;
        struct CURIOSITY_t {
            const char* primary_range = "128-159";
            float intensity_multiplier = 1.2;
            const char* sparkle_effect = "ENABLED";
        } CURIOSITY;
        struct FEAR_t {
            const char* primary_range = "160-191";
            float intensity_multiplier = 1.8;
            const char* dilation_effect = "ENABLED";
        } FEAR;
        struct HAPPINESS_t {
            const char* primary_range = "192-223";
            float intensity_multiplier = 1.1;
            const char* warmth_effect = "ENABLED";
        } HAPPINESS;
        struct BIRD_t {
            const char* primary_range = "32-95";
            float intensity_multiplier = 1.3;
            const char* special_effect = "FLYING_PATTERN";
            const char* wing_animation = "ENABLED";
        } BIRD;
    } mood_color_mapping;
    struct frame_processing_t {
        const char* buffer_stack_support = "ENABLED";
        const char* multi_eye_coordination = "ENABLED";
        const char* mood_based_adjustments = "REALTIME";
        const char* color_space = "RGB565";
    } frame_processing;
    struct timing_t {
        int hitCount = 1;
        const char* description = "Process all frames in buffer stack every loop";
    } timing;
    struct software_t {
        const char* init_function = "goblin_eye_init";
        const char* act_function = "goblin_eye_act";
    } software;
    const char* prototype_status = "implemented";
    bool tested = true;
    const char* notes[6] = { "Software-only component - no physical shape", "Code already fully implemented in goblin_eye.cpp/hpp", "Handles mood-based color palette adjustments", "Supports buffer stack processing for left/right eye coordination", "256-color organized palette with distinct mood ranges", "Real-time frame processing with SharedMemory mood integration" };
};

// Component definition sourced from config\subsystems\goblin_head.json
struct goblin_head_config {
    const char* relative_filename = "config/subsystems/goblin_head.json";
    const char* version = "3.0.0";
    const char* author = "config/author.json";
    const char* subsystem_type = "HEAD";
    const char* subsystem_id = "goblin_head_v1";
    const char* description = "Goblin head subsystem with facial expressions, sensors, and audio output - Focus on display/audio processing";
    const char* created = "2025-10-15";
    const char* controller = "ESP32_S3_R8N16";
    const char* coordinate_system = "skull_3d";
    const char* reference_point = "nose_center";
    const char* units = "MILLIMETERS";
    const char* name = "goblin_head";
    const char* component_type = "SUBSYSTEM_ASSEMBLY";
    struct timing_t {
        int hitCount = 25;
        const char* description = "Head coordination every 2.5 seconds";
    } timing;
    struct shape_assembly_t {
        const char* type = "SKULL_FRAME";
        const char* scad_file = "assets/shapes/scad/skull_generators/goblin_skull.scad";
        const char* stl_file = "assets/shapes/stl/skull_generators/goblin_skull.stl";
        const char* description = "Anatomical goblin skull frame with component mounting rings";
        const char* color_palette = "config/bots/bot_families/fantasy/goblin_family.json";
        struct mounting_points_t {
            struct eye_left_t {
                const char* type = "26mm_ring";
                float position[3] = { -26.67, 17.78, -8.89 };
                const char* units = "mm";
                const char* description = "Left eye socket mounting ring";
            } eye_left;
            struct eye_right_t {
                const char* type = "26mm_ring";
                float position[3] = { 26.67, 17.78, -8.89 };
                const char* units = "mm";
                const char* description = "Right eye socket mounting ring";
            } eye_right;
            struct nose_t {
                const char* type = "22x17mm_bracket";
                const char* position[3] = { 0, 0, 6.35 };
                const char* units = "mm";
                const char* description = "Nose sensor bracket";
            } nose;
            struct mouth_t {
                const char* type = "26mm_ring";
                const char* position[3] = { 0, -26.67, 0 };
                const char* units = "mm";
                const char* description = "Mouth display mounting ring";
            } mouth;
            struct ear_left_t {
                const char* type = "creature_specific";
                int position[3] = { -50, 25, 0 };
                const char* units = "mm";
                const char* description = "Left ear attachment point (goblin-specific)";
            } ear_left;
            struct ear_right_t {
                const char* type = "creature_specific";
                int position[3] = { 50, 25, 0 };
                const char* units = "mm";
                const char* description = "Right ear attachment point (goblin-specific)";
            } ear_right;
        } mounting_points;
    } shape_assembly;
    struct articulation_t {
        const char* neck_servos[2] = { "config/components/positioned/neck_pan_servo.json", "config/components/positioned/neck_tilt_servo.json" };
        int degrees_of_freedom = 2;
        int neck_pan_range_degrees = 180;
        int neck_tilt_range_degrees = 90;
    } articulation;
    struct mass_properties_t {
        const char* total_weight_g = "450";
        int center_of_gravity[3] = { 0, 0, -10 };
        const char* balance_point = "neck_attachment";
    } mass_properties;
    struct power_requirements_t {
        const char* voltage = "5V";
        const char* estimated_current_draw_a = "2.5";
        const char* display_power_w = "3.0";
        const char* audio_power_w = "2.0";
        const char* servo_power_w = "6.0";
    } power_requirements;
    struct processing_responsibilities_t {
        const char* description = "Head focuses on high-frequency display/audio updates without system-level overhead";
        const char* tasks[7] = { "Dual GC9A01 display rendering (60 FPS capable)", "I2S audio playback and mixing", "HC-SR04 sensor polling and filtering", "Facial expression animation engine", "Mood-driven display effects", "Neck servo articulation control", "Respond to commands from torso master" };
        const char* excluded_tasks[4] = { "WiFi management (handled by torso)", "Network coordination (handled by torso)", "Telemetry aggregation (handled by torso)", "System-wide behavior planning (handled by torso)" };
    } processing_responsibilities;
};

// Component definition sourced from config\components\positioned\goblin_left_ear.json
struct goblin_left_ear_config {
    const char* component_type = "POSITIONED_COMPONENT";
    struct position_t {
        const char* units = "INCH";
        const char* x = "0.0 INCH";
        const char* coordinate_system = "skull_3d";
        const char* z = "0.0 INCH";
        const char* reference_point = "nose_center";
        const char* y = "0.0 INCH";
    } position;
    const char* name = "goblin_left_ear";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    struct software_t {
        const char* act_function = "goblin_left_ear_act";
        const char* init_function = "goblin_left_ear_init";
        int hitCount = 10;
    } software;
    const char* relative_filename = "config/components/positioned/goblin_left_ear.json";
};

// Component definition sourced from config\components\positioned\goblin_left_eye.json
struct goblin_left_eye_config {
    const char* relative_filename = "config/components/positioned/goblin_left_eye.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "goblin_left_eye";
    const char* component_type = "POSITIONED_COMPONENT";
    const char* subsystem = "HEAD";
    struct mounting_architecture_t {
        const char* type = "two_tier";
        const char* hardware_mount = "display_basic_mount";
        const char* decorative_shell = "goblin_left_eye_shell";
    } mounting_architecture;
    const char* coordinate_system = "skull_3d";
    const char* reference_point = "nose_center";
    struct position_t {
        const char* x = "-1.05 INCH";
        const char* y = "+0.7 INCH";
        const char* z = "-0.35 INCH";
    } position;
    struct orientation_t {
        const char* tilt = "0 DEGREES";
        const char* rotation = "0 DEGREES";
        const char* roll = "0 DEGREES";
    } orientation;
    const char* function = "primary_display_left";
    const char* description = "Left eye display animation";
    struct software_t {
        const char* init_function = "goblin_left_eye_init";
        const char* act_function = "goblin_left_eye_act";
    } software;
    struct animatronic_cache_t {
        const char* animation_buffers = "LEFT_EYE_BUFFER";
        const char* buffer_allocation = "STACK_PUSH";
        const char* coordinates = "LEFT_POSITION";
    } animatronic_cache;
    struct timing_t {
        int hitCount = 1;
    } timing;
    const char* hardware_type = "POSITIONED_COMPONENT";
};

// Component definition sourced from config\components\positioned\goblin_mouth.json
struct goblin_mouth_config {
    const char* relative_filename = "config/components/positioned/goblin_mouth.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "goblin_mouth";
    const char* component_type = "POSITIONED_COMPONENT";
    const char* subsystem = "HEAD";
    const char* coordinate_system = "skull_3d";
    const char* reference_point = "nose_center";
    struct position_t {
        const char* x = "0 INCH";
        const char* y = "-1.05 INCH";
        const char* z = "0 INCH";
    } position;
    struct orientation_t {
        const char* tilt = "0 DEGREES";
        const char* rotation = "0 DEGREES";
        const char* roll = "0 DEGREES";
    } orientation;
    const char* function = "mouth_display";
    const char* description = "Mouth display animation";
    struct timing_t {
        int hitCount = 36000;
    } timing;
    const char* hardware_type = "POSITIONED_COMPONENT";
};

// Component definition sourced from config\components\creature_specific\goblin_mouth.json
struct goblin_mouth_config {
    const char* relative_filename = "config/components/creature_specific/goblin_mouth.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "goblin_mouth";
    const char* subsystem = "HEAD";
    const char* component_type = "CREATURE_SPECIFIC_DISPLAY";
    const char* description = "Shared goblin mouth processing logic with speech animation and mood-based rendering";
    const char* created = "2025-10-23";
    struct component_constraints_t {
        const char* required_contained_types[1] = { "DISPLAY_DRIVER" };
        const char* interface_requirements[3] = { "getBuffer", "getFrameSize", "getFrameRowSize" };
    } component_constraints;
    struct creature_display_profile_t {
        const char* species = "GOBLIN";
        const char* mouth_color_base = "DARK_RED";
        const char* teeth_style = "JAGGED_SHARP";
        const char* expression_range = "SNARL_TO_GRIN";
        const char* speech_responsiveness = "HIGH";
        const char* mood_responsiveness = "HIGH";
    } creature_display_profile;
    struct palette_system_t {
        int palette_size = 256;
        struct color_ranges_t {
            const char* lips_gums = "0-31";
            const char* teeth_base = "32-63";
            const char* tongue_base = "64-95";
            const char* anger_reds = "96-127";
            const char* speaking_highlights = "128-159";
            const char* fear_purples = "160-191";
            const char* happiness_pinks = "192-223";
            const char* special_effects = "224-255";
        } color_ranges;
    } palette_system;
    struct speech_animation_t {
        struct phoneme_mapping_t {
            const char* A_E_I = "WIDE_OPEN";
            const char* O_U = "ROUND_OPEN";
            const char* M_B_P = "CLOSED";
            const char* F_V = "LOWER_LIP_BITE";
            const char* TH = "TONGUE_OUT";
            const char* L_R = "TONGUE_UP";
            const char* S_Z = "SLIGHT_OPEN";
        } phoneme_mapping;
        const char* transition_speed = "FAST";
        const char* hold_duration = "SHORT";
    } speech_animation;
    struct timing_t {
        int hitCount = 1;
        const char* description = "Process mouth animation every loop for speech responsiveness";
    } timing;
    struct software_t {
        const char* init_function = "goblin_mouth_init";
        const char* act_function = "goblin_mouth_act";
    } software;
    const char* prototype_status = "designed";
    bool tested = false;
    const char* notes[6] = { "Software-only component - no physical shape", "Provides display driver interface abstraction for mouth displays", "Handles speech animation and mood-based mouth expressions", "Supports phoneme-based speech animation mapping", "256-color organized palette with speech and mood ranges", "Real-time speech processing with SharedMemory integration" };
};

// Component definition sourced from config\components\positioned\goblin_nose.json
struct goblin_nose_config {
    const char* relative_filename = "config/components/positioned/goblin_nose.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "goblin_nose";
    const char* component_type = "POSITIONED_COMPONENT";
    const char* subsystem = "HEAD";
    struct mounting_architecture_t {
        const char* type = "two_tier";
        const char* hardware_mount = "sensor_basic_mount";
        const char* decorative_shell = "goblin_nose_shell";
    } mounting_architecture;
    const char* coordinate_system = "skull_3d";
    const char* reference_point = "nose_center";
    struct position_t {
        const char* x = "0 INCH";
        const char* y = "0 INCH";
        const char* z = "+0.25 INCH";
    } position;
    struct orientation_t {
        const char* tilt = "0 DEGREES";
        const char* rotation = "0 DEGREES";
        const char* roll = "0 DEGREES";
    } orientation;
    const char* function = "proximity_sensor";
    const char* description = "Proximity sensor monitoring";
    struct timing_t {
        int hitCount = 180000;
    } timing;
    const char* hardware_type = "POSITIONED_COMPONENT";
};

// Component definition sourced from config\components\positioned\goblin_right_ear.json
struct goblin_right_ear_config {
    const char* component_type = "POSITIONED_COMPONENT";
    struct position_t {
        const char* units = "INCH";
        const char* x = "0.0 INCH";
        const char* coordinate_system = "skull_3d";
        const char* z = "0.0 INCH";
        const char* reference_point = "nose_center";
        const char* y = "0.0 INCH";
    } position;
    const char* name = "goblin_right_ear";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    struct software_t {
        const char* act_function = "goblin_right_ear_act";
        const char* init_function = "goblin_right_ear_init";
        int hitCount = 10;
    } software;
    const char* relative_filename = "config/components/positioned/goblin_right_ear.json";
};

// Component definition sourced from config\components\positioned\goblin_right_eye.json
struct goblin_right_eye_config {
    const char* relative_filename = "config/components/positioned/goblin_right_eye.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "goblin_right_eye";
    const char* component_type = "POSITIONED_COMPONENT";
    const char* subsystem = "HEAD";
    const char* coordinate_system = "skull_3d";
    const char* reference_point = "nose_center";
    struct position_t {
        const char* x = "+1.05 INCH";
        const char* y = "+0.7 INCH";
        const char* z = "-0.35 INCH";
    } position;
    struct orientation_t {
        const char* tilt = "0 DEGREES";
        const char* rotation = "0 DEGREES";
        const char* roll = "0 DEGREES";
    } orientation;
    const char* function = "bird_display_right";
    const char* description = "Right eye display with bird animation";
    const char* default_mood = "BIRD";
    struct animatronic_cache_t {
        const char* animation_buffers = "RIGHT_EYE_BUFFER";
        const char* buffer_allocation = "STACK_PUSH";
        const char* coordinates = "RIGHT_POSITION";
    } animatronic_cache;
    struct timing_t {
        int hitCount = 1;
    } timing;
    const char* hardware_type = "POSITIONED_COMPONENT";
};

// Component definition sourced from config\components\positioned\goblin_speaker.json
struct goblin_speaker_config {
    const char* relative_filename = "config/components/positioned/goblin_speaker.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "goblin_speaker";
    const char* component_type = "POSITIONED_COMPONENT";
    const char* subsystem = "HEAD";
    const char* coordinate_system = "skull_3d";
    const char* reference_point = "nose_center";
    struct position_t {
        const char* x = "-0.5 INCH";
        const char* y = "+0.5 INCH";
        const char* z = "-1.0 INCH";
    } position;
    struct orientation_t {
        const char* tilt = "0 DEGREES";
        const char* rotation = "0 DEGREES";
        const char* roll = "0 DEGREES";
    } orientation;
    const char* function = "primary_audio_output";
    const char* description = "Audio output processing";
    struct timing_t {
        int hitCount = 84000;
    } timing;
    const char* hardware_type = "POSITIONED_COMPONENT";
};

// Component definition sourced from config\components\hardware\hc_sr04_sensor.json
struct hc_sr04_ultrasonic_distance_sensor_config {
    const char* relative_filename = "config/components/hardware/hc_sr04_sensor.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* hardware_type = "HC_SR04_SENSOR";
    const char* name = "hc_sr04_ultrasonic_distance_sensor";
    struct physical_specs_t {
        const char* width = "1.8 INCH";
        const char* height = "0.7 INCH";
        const char* depth = "0.6 INCH";
        const char* sensor_spacing = "1.0 INCH";
        struct mounting_holes_t {
            int count = 2;
            const char* diameter = "0.08 INCH";
            const char* spacing = "1.5 INCH";
        } mounting_holes;
    } physical_specs;
    struct electrical_specs_t {
        const char* supply_voltage = "5V";
        const char* interface = "GPIO_PAIR";
        const char* current_consumption = "15mA";
    } electrical_specs;
    struct sensor_config_t {
        const char* range_min = "0.08 INCH";
        const char* range_max = "157 INCH";
        const char* accuracy = "0.12 INCH";
        const char* beam_angle = "15 DEGREES";
    } sensor_config;
    struct software_t {
        const char* init_function = "hc_sr04_ultrasonic_distance_sensor_init";
        const char* act_function = "hc_sr04_ultrasonic_distance_sensor_act";
    } software;
};

// Component definition sourced from config\components\hardware\servo_sg90_micro.json
struct servo_sg90_micro_config {
    const char* relative_filename = "config/components/hardware/servo_sg90_micro.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "servo_sg90_micro";
    const char* component_type = "SERVO_MOTOR";
    const char* hardware_id = "SERVO_SG90_MICRO";
    const char* description = "Micro servo motor for precise position control in small animatronics";
    const char* created = "2025-10-12";
    int hitCount = 1;
    struct physical_specifications_t {
        const char* dimensions = "23x12.2x29 MM";
        const char* weight = "9 G";
        const char* shaft_diameter = "4 MM";
        int mounting_holes = 2;
        const char* rotation_range = "180 DEG";
        const char* operating_voltage = "4.8V-6V";
        const char* stall_current = "650 MA";
        const char* operating_current = "220 MA";
    } physical_specifications;
    struct electrical_requirements_t {
        const char* power_supply_voltage = "5V";
        const char* control_voltage = "3.3V";
        const char* interface_type = "PWM";
        const char* pwm_frequency = "50 HZ";
        const char* pulse_width_range = "1-2 MS";
        const char* logic_compatibility = "3.3V_TOLERANT";
    } electrical_requirements;
    struct gpio_requirements_t {
        int control_pin = 1;
        int power_pins = 1;
        int ground_pins = 1;
        int total_connections = 3;
    } gpio_requirements;
    struct performance_specifications_t {
        const char* rotation_speed = "0.1 SEC/60_DEG";
        const char* torque = "1.8 KG_CM";
        const char* precision = "1 DEG";
        const char* backlash = "1 DEG";
        const char* operating_temperature = "-30_TO_60_C";
        const char* duty_cycle = "CONTINUOUS";
    } performance_specifications;
    struct control_capabilities_t {
        bool position_feedback = false;
        bool speed_control = false;
        bool torque_limiting = false;
        bool smooth_acceleration = true;
        bool calibration_required = true;
    } control_capabilities;
    const char* use_cases[8] = { "eye_movement", "ear_articulation", "mouth_opening", "head_turning", "tail_wagging", "wing_flapping", "jaw_movement", "eyebrow_raising" };
    struct family_suitability_t {
        const char* robot = "GOOD";
        const char* android = "EXCELLENT";
        const char* goblin = "EXCELLENT";
        const char* vampire = "GOOD";
        const char* zombie = "MODERATE";
        const char* ghost = "POOR";
        const char* dragon = "EXCELLENT";
        const char* cat = "EXCELLENT";
        const char* bear = "GOOD";
    } family_suitability;
    struct mounting_requirements_t {
        bool servo_horn_required = true;
        const char* mounting_bracket = "OPTIONAL";
        const char* vibration_damping = "RECOMMENDED";
        const char* wire_management = "3_WIRE_PIGTAIL";
    } mounting_requirements;
    struct software_t {
        const char* init_function = "servo_sg90_micro_init";
        const char* act_function = "servo_sg90_micro_act";
    } software;
    const char* hardware_type = "SERVO_MOTOR";
};

// Component definition sourced from config\components\hardware\speaker.json
struct speaker_config {
    const char* relative_filename = "config/components/hardware/speaker.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* hardware_type = "I2S_SPEAKER";
    const char* name = "speaker";
    struct physical_specs_t {
        const char* diameter = "1.5 INCH";
        const char* thickness = "0.3 INCH";
        struct mounting_holes_t {
            int count = 2;
            const char* diameter = "0.08 INCH";
            const char* spacing = "1.2 INCH";
        } mounting_holes;
    } physical_specs;
    struct electrical_specs_t {
        const char* supply_voltage = "3.3V";
        const char* interface = "I2S";
        const char* power_output = "3W";
        const char* current_consumption = "500mA";
    } electrical_specs;
    struct audio_specs_t {
        const char* frequency_range = "100-20000 Hz";
        const char* sample_rates[5] = { "8000", "16000", "22050", "44100", "48000" };
        int bit_depths[3] = { 16, 24, 32 };
    } audio_specs;
    struct mounting_architecture_t {
        const char* approach = "two_tier";
        struct shape_generation_t {
            const char* scad_template = "templates/speaker_enclosure.scad";
            struct manufacturer_variants_t {
                struct generic_40mm_t {
                    const char* stl_file = "basic_mounts/speaker_40mm_generic.stl";
                    struct parameters_t {
                        float speaker_diameter = 40.0;
                        int mounting_holes = 4;
                        float hole_diameter = 3.0;
                        float hole_pcd = 35.0;
                        const char* mounting_type = "through_hole";
                        float depth = 12.0;
                    } parameters;
                    const char* description = "Generic 40mm speaker with 4x M3 holes at 35mm PCD";
                    const char* notes = "Most common design from Chinese manufacturers";
                } generic_40mm;
                struct adafruit_3885_t {
                    const char* stl_file = "basic_mounts/speaker_40mm_adafruit.stl";
                    struct parameters_t {
                        float speaker_diameter = 40.0;
                        int mounting_tabs = 2;
                        float tab_width = 8.0;
                        float tab_thickness = 2.0;
                        float tab_spacing = 36.0;
                        const char* mounting_type = "tab_slots";
                        float depth = 10.5;
                    } parameters;
                    const char* description = "Adafruit #3885 - 40mm 4? 3W speaker with mounting tabs";
                    const char* datasheet = "https://www.adafruit.com/product/3885";
                } adafruit_3885;
                struct sparkfun_com14023_t {
                    const char* stl_file = "basic_mounts/speaker_40mm_sparkfun.stl";
                    struct parameters_t {
                        float speaker_diameter = 40.0;
                        int snap_fit_clips = 4;
                        float clip_depth = 1.5;
                        float clip_angle = 15.0;
                        const char* mounting_type = "snap_fit";
                        float depth = 11.0;
                    } parameters;
                    const char* description = "SparkFun COM-14023 - 40mm speaker with snap-fit enclosure";
                    const char* datasheet = "https://www.sparkfun.com/products/14023";
                } sparkfun_com14023;
                struct tbd_awaiting_delivery_t {
                    const char* stl_file = "basic_mounts/speaker_40mm_tbd.stl";
                    struct parameters_t {
                        float speaker_diameter = 40.0;
                        const char* mounting_type = "unknown";
                        const char* notes = "Will measure upon arrival";
                    } parameters;
                    const char* description = "Generic 40mm speaker mount for standard audio drivers";
                    const char* status = "AWAITING_HARDWARE";
                } tbd_awaiting_delivery;
            } manufacturer_variants;
            const char* default_variant = "generic_40mm";
            const char* usage_notes = "When speakers arrive: 1) Measure physical dimensions, 2) Photograph mounting holes, 3) Create exact variant parameters, 4) Generate STL, 5) Test print bracket";
        } shape_generation;
    } mounting_architecture;
    struct testing_status_t {
        bool hardware_available = false;
        const char* expected_arrival = "few days";
        const char* testing_strategy = "Use stub component until hardware arrives, then measure and create exact manufacturer variant";
    } testing_status;
};

// Component definition sourced from config\components\interfaces\spi_bus.json
struct spi_bus_config {
    const char* relative_filename = "config/components/interfaces/spi_bus.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "spi_bus";
    const char* hardware_type = "BUS_INTERFACE";
    const char* bus_type = "SPI";
    const char* bus_name = "VSPI";
    const char* description = "ESP32 VSPI bus interface for SPI communication";
    struct pin_requirements_t {
        const char* shared_pins_needed = "[{\"function\": \"SPI_SCLK\", \"count\": 1, \"description\": \"SPI clock signal\"}, {\"function\": \"SPI_Q\", \"count\": 1, \"description\": \"SPI MISO (Master In Slave Out)\"}]";
        const char* unique_pins_needed = "[{\"function\": \"SPI_CS\", \"count\": 1, \"description\": \"SPI chip select (unique per device)\"}, {\"function\": \"SPI_HD\", \"count\": 1, \"description\": \"SPI MOSI (Master Out Slave In) or hold signal\"}]";
    } pin_requirements;
    const char* component_type = "INTERFACE_BUS";
    const char* interface_id = "SPI_BUS";
    const char* interface_type = "SPI_BUS";
    struct timing_t {
        int hitCount = 1;
    } timing;
    struct software_t {
        const char* init_function = "spi_bus_init";
        const char* act_function = "spi_bus_act";
    } software;
    struct pin_allocation_t {
        const char* shared_pins[4] = { "clock", "data_output", "data_input", "reset" };
        const char* device_pins[2] = { "chip_select", "data_command" };
    } pin_allocation;
    struct bus_config_t {
        const char* frequency = "10000000";
        int mode = 0;
    } bus_config;
    struct hardware_t {
        struct esp32_specific_t {
            const char* host_device = "SPI2_HOST";
            int dma_channel = 1;
            int max_transfer_size = 4092;
        } esp32_specific;
    } hardware;
    const char* notes = "VSPI bus on ESP32. Shared pins (SCLK, MISO) can be used by multiple devices. Unique pins (CS, MOSI) are per-device.";
};

// ---------------------------------------------------------------------------
// Function prototypes
// ---------------------------------------------------------------------------
esp_err_t hw496_microphone_init(void);
void hw496_microphone_act(void);
esp_err_t gc9a01_init(void);
void gc9a01_act(void);
esp_err_t generic_spi_display_init(void);
void generic_spi_display_act(void);
esp_err_t goblin_eye_init(void);
void goblin_eye_act(void);
esp_err_t goblin_head_init(void);
void goblin_head_act(void);
esp_err_t goblin_left_ear_init(void);
void goblin_left_ear_act(void);
esp_err_t goblin_left_eye_init(void);
void goblin_left_eye_act(void);
esp_err_t goblin_mouth_init(void);
void goblin_mouth_act(void);
esp_err_t goblin_mouth_init(void);
void goblin_mouth_act(void);
esp_err_t goblin_nose_init(void);
void goblin_nose_act(void);
esp_err_t goblin_right_ear_init(void);
void goblin_right_ear_act(void);
esp_err_t goblin_right_eye_init(void);
void goblin_right_eye_act(void);
esp_err_t goblin_speaker_init(void);
void goblin_speaker_act(void);
esp_err_t hc_sr04_ultrasonic_distance_sensor_init(void);
void hc_sr04_ultrasonic_distance_sensor_act(void);
esp_err_t servo_sg90_micro_init(void);
void servo_sg90_micro_act(void);
esp_err_t speaker_init(void);
void speaker_act(void);
esp_err_t spi_bus_init(void);
void spi_bus_act(void);

// Declarations from config\components\hardware\hw496_microphone.hdr
// HW-496 MEMS Microphone Component Header
// Uses generic microphone driver with HW496-specific configuration

#ifndef hw496_microphone_H
#define hw496_microphone_H

#include "esp_err.h"

// Test declaration
extern int test_hw496_variable;

// Function declarations for dispatch table
esp_err_t hw496_microphone_init(void);
void hw496_microphone_act(void);

#endif // hw496_microphone_H

#endif // GOBLIN_HEAD_COMPONENT_FUNCTIONS_HPP
