#ifndef TEST_HEAD_COMPONENT_FUNCTIONS_HPP
#define TEST_HEAD_COMPONENT_FUNCTIONS_HPP

#include <cstddef>
#include <cstdint>
#include "esp_err.h"

// Auto-generated by tools/generate_tables.py
// Subsystem: test_head
// Controller: ESP32_S3_DEVKITC_1

// Component definition sourced from config\components\hardware\gc9a01.json
struct gc9a01_config {
    const char* relative_filename = "config/components/hardware/gc9a01.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* hardware_type = "GC9A01_DISPLAY";
    const char* component_type = "DISPLAY_DRIVER";
    bool display_driver = true;
    const char* name = "gc9a01";
    const char* subsystem = "HEAD";
    struct physical_specs_t {
        const char* diameter = "1.28 INCH";
        const char* thickness = "0.08 INCH";
        const char* resolution = "240x240";
        struct mounting_holes_t {
            int count = 4;
            const char* diameter = "0.1 INCH";
            const char* spacing = "1.1 INCH";
        } mounting_holes;
    } physical_specs;
    struct timing_t {
        int hitCount = 1;
        const char* description = "Display updates every loop for smooth animation";
    } timing;
    struct pin_mapping_t {
        const char* description = "GC9A01 displays have varying pin labels depending on manufacturer. See MakerNames.json for complete mapping.";
        const char* manufacturer_mapping_reference = "config/components/interfaces/MakerNames.json";
        struct generic_pins_t {
            struct clock_t {
                const char* function = "SPI Clock";
                bool required = true;
                const char* manufacturer_labels[4] = { "CLK", "SCK", "SCLK", "SCL" };
            } clock;
            struct data_input_t {
                const char* function = "SPI Master Out Slave In (Data)";
                bool required = true;
                const char* manufacturer_labels[4] = { "MOSI", "SDA", "SDI", "DIN" };
            } data_input;
            struct data_command_t {
                const char* function = "Data/Command Select";
                bool required = true;
                const char* manufacturer_labels[4] = { "DC", "D/C", "RS", "A0" };
            } data_command;
            struct chip_select_t {
                const char* function = "Chip Select (Slave Select)";
                bool required = true;
                const char* manufacturer_labels[3] = { "CS", "SS", "CE" };
            } chip_select;
            struct reset_t {
                const char* function = "Hardware Reset";
                bool required = true;
                const char* manufacturer_labels[3] = { "RST", "RESET", "RES" };
            } reset;
            struct backlight_t {
                const char* function = "Backlight Control (PWM)";
                bool required = false;
                const char* manufacturer_labels[3] = { "BL", "BLK", "LED" };
            } backlight;
            struct power_positive_t {
                const char* function = "Power Supply (3.3V)";
                bool required = true;
                const char* manufacturer_labels[4] = { "VCC", "VDD", "3V3", "+3.3V" };
            } power_positive;
            struct power_ground_t {
                const char* function = "Ground Reference";
                bool required = true;
                const char* manufacturer_labels[3] = { "GND", "VSS", "0V" };
            } power_ground;
        } generic_pins;
        struct common_manufacturer_variations_t {
            struct variation_1_t {
                const char* description = "Most common pinout (your displays)";
                const char* pins_exposed[7] = { "SCK", "SDA", "DC", "CS", "RST", "VCC", "GND" };
            } variation_1;
            struct variation_2_t {
                const char* description = "Waveshare/Adafruit style";
                const char* pins_exposed[8] = { "CLK", "MOSI", "DC", "CS", "RST", "BL", "VCC", "GND" };
            } variation_2;
            struct variation_3_t {
                const char* description = "Generic Chinese modules";
                const char* pins_exposed[8] = { "SCLK", "SDI", "RS", "CS", "RESET", "LED", "VDD", "GND" };
            } variation_3;
        } common_manufacturer_variations;
    } pin_mapping;
    struct driver_config_t {
        int rotation = 0;
        bool invert_colors = false;
        bool backlight_pwm = true;
    } driver_config;
    struct color_specifications_t {
        const char* color_mode = "full_color";
        int bit_depth = 16;
        const char* color_space = "RGB565";
        int colors_supported = 65536;
        const char* description = "Full color 16-bit RGB display";
    } color_specifications;
    struct mood_color_response_t {
        bool supports_dynamic_colors = true;
        bool full_spectrum_available = true;
        struct mood_mapping_t {
            const char* ANGER = "#FF0000";
            const char* FEAR = "#800080";
            const char* HAPPINESS = "#FFFF00";
            const char* CONTENTMENT = "#00FF00";
            const char* CURIOSITY = "#0080FF";
            const char* IRRITATION = "#FF8000";
            const char* HUNGER = "#FF0080";
            const char* AFFECTION = "#FF69B4";
        } mood_mapping;
    } mood_color_response;
    struct software_t {
        const char* init_function = "gc9a01_init";
        const char* act_function = "gc9a01_act";
    } software;
    const char* required_interface_functions[3] = { "getBuffer", "getFrameSize", "getFrameRowSize" };
};

// Component definition sourced from config\components\drivers\generic_spi_data_driver.json
struct generic_spi_data_driver_config {
    const char* name = "generic_spi_data_driver";
    const char* type = "driver";
    const char* version = "1.0.0";
    const char* author = "config/authors/ai_agent.json";
    const char* description = "Generic driver for SPI peripherals using the spi_data_bus for full-duplex communication.";
    const char* created = "2025-11-01";
    const char* component_type = "spi_driver";
    const char* relative_filename = "config/components/drivers/generic_spi_data_driver.json";
    struct software_t {
        const char* init_function = "generic_spi_data_driver_init";
        const char* act_function = "generic_spi_data_driver_act";
    } software;
};

// Component definition sourced from config\components\drivers\generic_spi_display.json
struct generic_spi_display_config {
    const char* name = "generic_spi_display";
    const char* type = "driver";
    const char* version = "1.0.0";
    const char* author = "config/authors/ai_agent.json";
    const char* description = "Generic SPI display driver for ESP32-S3 with configurable pin mapping and display parameters";
    const char* created = "2025-10-29";
    const char* hardware_type = "display_driver";
    struct capabilities_t {
        const char* bus_type = "SPI";
        const char* max_resolution = "240x240";
        const char* color_depth = "16-bit";
        const char* interface_speed = "up to 80MHz";
        const char* supported_displays[4] = { "GC9A01", "ILI9341", "ST7789", "custom SPI displays" };
    } capabilities;
    struct electrical_specs_t {
        const char* voltage_range = "3.3V";
        const char* current_draw = "50-200mA";
        const char* spi_mode = "Mode 0 or 3";
        const char* clock_polarity = "configurable";
    } electrical_specs;
    struct gpio_requirements_t {
        const char* required_pins[6] = { "MOSI", "SCLK", "CS", "DC", "RST", "BL" };
        const char* optional_pins[1] = { "MISO" };
        int pin_count = 5;
    } gpio_requirements;
    struct software_t {
        const char* init_function = "generic_spi_display_init";
        const char* act_function = "generic_spi_display_act";
        const char* api_functions[6] = { "spi_display_init(uint8_t cs_pin, uint8_t dc_pin, uint8_t rst_pin, uint8_t bl_pin)", "spi_display_write_pixel(uint16_t x, uint16_t y, uint16_t color)", "spi_display_fill_rect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color)", "spi_display_draw_bitmap(uint16_t x, uint16_t y, const uint16_t* bitmap, uint16_t w, uint16_t h)", "spi_display_set_brightness(uint8_t brightness)", "spi_display_clear(uint16_t color)" };
    } software;
    struct compatibility_t {
        bool esp32_s3 = true;
        bool esp32_s2 = true;
        bool esp32 = false;
        const char* chip_variants[2] = { "ESP32-S3-DevKitC-1", "ESP32-S3-WROOM-1" };
    } compatibility;
    struct dependencies_t {
        const char* esp_idf_components[2] = { "spi", "gpio" };
        // Empty array: external_libraries
    } dependencies;
    const char* relative_filename = "config/components/drivers/generic_spi_display.json";
};

// Component definition sourced from config\components\creature_specific\goblin_eye.json
struct goblin_eye_config {
    const char* relative_filename = "config/components/creature_specific/goblin_eye.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "goblin_eye";
    const char* subsystem = "HEAD";
    const char* type = "CREATURE_SPECIFIC_DISPLAY";
    const char* description = "Shared goblin eye processing logic with palette and mood-based rendering";
    const char* created = "2025-10-22";
    struct component_constraints_t {
        const char* required_contained_types[1] = { "DISPLAY_DRIVER" };
        const char* interface_requirements[3] = { "getBuffer", "getFrameSize", "getFrameRowSize" };
    } component_constraints;
    struct creature_display_profile_t {
        const char* species = "GOBLIN";
        const char* eye_color_base = "AMBER_GOLD";
        const char* pupil_style = "VERTICAL_SLIT";
        const char* expression_range = "MENACING_TO_CURIOUS";
        const char* mood_responsiveness = "HIGH";
    } creature_display_profile;
    struct palette_system_t {
        int palette_size = 256;
        struct color_ranges_t {
            const char* eyelid_pupil = "0-31";
            const char* iris_base = "32-63";
            const char* highlights = "64-95";
            const char* bird_colors = "64-95";
            const char* anger_reds = "96-127";
            const char* curiosity_greens = "128-159";
            const char* fear_blues = "160-191";
            const char* happiness_yellows = "192-223";
            const char* special_effects = "224-255";
        } color_ranges;
    } palette_system;
    struct mood_color_mapping_t {
        struct ANGER_t {
            const char* primary_range = "96-127";
            float intensity_multiplier = 1.5;
            const char* glow_effect = "ENABLED";
        } ANGER;
        struct CURIOSITY_t {
            const char* primary_range = "128-159";
            float intensity_multiplier = 1.2;
            const char* sparkle_effect = "ENABLED";
        } CURIOSITY;
        struct FEAR_t {
            const char* primary_range = "160-191";
            float intensity_multiplier = 1.8;
            const char* dilation_effect = "ENABLED";
        } FEAR;
        struct HAPPINESS_t {
            const char* primary_range = "192-223";
            float intensity_multiplier = 1.1;
            const char* warmth_effect = "ENABLED";
        } HAPPINESS;
        struct BIRD_t {
            const char* primary_range = "32-95";
            float intensity_multiplier = 1.3;
            const char* special_effect = "FLYING_PATTERN";
            const char* wing_animation = "ENABLED";
        } BIRD;
    } mood_color_mapping;
    struct frame_processing_t {
        const char* buffer_stack_support = "ENABLED";
        const char* multi_eye_coordination = "ENABLED";
        const char* mood_based_adjustments = "REALTIME";
        const char* color_space = "RGB565";
    } frame_processing;
    struct timing_t {
        int hitCount = 1;
        const char* description = "Process all frames in buffer stack every loop";
    } timing;
    struct software_t {
        const char* init_function = "goblin_eye_init";
        const char* act_function = "goblin_eye_act";
    } software;
    const char* prototype_status = "implemented";
    bool tested = true;
    const char* notes[6] = { "Software-only component - no physical shape", "Code already fully implemented in goblin_eye.cpp/hpp", "Handles mood-based color palette adjustments", "Supports buffer stack processing for left/right eye coordination", "256-color organized palette with distinct mood ranges", "Real-time frame processing with SharedMemory mood integration" };
};

// Component definition sourced from config\components\creature_specific\goblin_left_eye.json
struct goblin_left_eye_config {
    const char* relative_filename = "config/components/creature_specific/goblin_left_eye.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "goblin_left_eye";
    const char* component_type = "POSITIONED_COMPONENT";
    const char* subsystem = "HEAD";
    struct mounting_architecture_t {
        const char* type = "two_tier";
        const char* hardware_mount = "display_basic_mount";
        const char* decorative_shell = "goblin_left_eye_shell";
    } mounting_architecture;
    const char* coordinate_system = "skull_3d";
    const char* reference_point = "nose_center";
    struct position_t {
        const char* x = "-1.05 INCH";
        const char* y = "+0.7 INCH";
        const char* z = "-0.35 INCH";
    } position;
    struct orientation_t {
        const char* tilt = "0 DEGREES";
        const char* rotation = "0 DEGREES";
        const char* roll = "0 DEGREES";
    } orientation;
    const char* function = "primary_display_left";
    const char* description = "Left eye display animation";
    struct software_t {
        const char* init_function = "goblin_left_eye_init<T>";
        const char* act_function = "goblin_left_eye_act<T>";
    } software;
    struct animatronic_cache_t {
        const char* animation_buffers = "LEFT_EYE_BUFFER";
        const char* buffer_allocation = "STACK_PUSH";
        const char* coordinates = "LEFT_POSITION";
    } animatronic_cache;
    struct timing_t {
        int hitCount = 200;
    } timing;
    const char* hardware_type = "POSITIONED_COMPONENT";
};

// Component definition sourced from config\components\creature_specific\goblin_right_eye.json
struct goblin_right_eye_config {
    const char* relative_filename = "config/components/creature_specific/goblin_right_eye.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "goblin_right_eye";
    const char* component_type = "POSITIONED_COMPONENT";
    const char* subsystem = "HEAD";
    const char* coordinate_system = "skull_3d";
    const char* reference_point = "nose_center";
    struct position_t {
        const char* x = "+1.05 INCH";
        const char* y = "+0.7 INCH";
        const char* z = "-0.35 INCH";
    } position;
    struct orientation_t {
        const char* tilt = "0 DEGREES";
        const char* rotation = "0 DEGREES";
        const char* roll = "0 DEGREES";
    } orientation;
    const char* function = "bird_display_right";
    const char* description = "Right eye display with bird animation";
    const char* default_mood = "BIRD";
    struct animatronic_cache_t {
        const char* animation_buffers = "RIGHT_EYE_BUFFER";
        const char* buffer_allocation = "STACK_PUSH";
        const char* coordinates = "RIGHT_POSITION";
    } animatronic_cache;
    struct timing_t {
        int hitCount = 200;
    } timing;
    const char* hardware_type = "POSITIONED_COMPONENT";
};

// Component definition sourced from config\components\interfaces\spi_bus.json
struct spi_bus_config {
    const char* relative_filename = "config/components/interfaces/spi_bus.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "spi_bus";
    const char* hardware_type = "BUS_INTERFACE";
    const char* bus_type = "SPI";
    const char* bus_name = "VSPI";
    const char* description = "ESP32 VSPI bus interface for SPI communication (bidirectional MOSI/MISO for sensors)";
    struct pin_requirements_t {
        const char* shared_pins_needed = "[{\"function\": \"SPI_SCLK\", \"count\": 1, \"description\": \"SPI clock signal\"}, {\"function\": \"SPI_Q\", \"count\": 1, \"description\": \"SPI MISO (Master In Slave Out)\"}]";
        const char* unique_pins_needed = "[{\"function\": \"SPI_CS\", \"count\": 1, \"description\": \"SPI chip select (unique per device)\"}, {\"function\": \"SPI_HD\", \"count\": 1, \"description\": \"SPI MOSI (Master Out Slave In) or hold signal\"}]";
    } pin_requirements;
    const char* component_type = "INTERFACE_BUS";
    const char* interface_id = "SPI_BUS";
    const char* interface_type = "SPI_BUS";
    struct timing_t {
        int hitCount = 1;
    } timing;
    struct software_t {
        const char* init_function = "spi_bus_init";
        const char* act_function = "spi_bus_act";
    } software;
    struct pin_allocation_t {
        const char* shared_pins[4] = { "clock", "data_output", "data_input", "reset" };
        const char* device_pins[2] = { "chip_select", "data_command" };
    } pin_allocation;
    struct bus_config_t {
        const char* frequency = "10000000";
        int mode = 0;
    } bus_config;
    struct hardware_t {
        struct esp32_specific_t {
            const char* host_device = "SPI2_HOST";
            int dma_channel = 1;
            int max_transfer_size = 4092;
        } esp32_specific;
    } hardware;
    const char* notes = "VSPI bus on ESP32. Shared pins (SCLK, MISO) can be used by multiple devices. Unique pins (CS, MOSI) are per-device.";
};

// Component definition sourced from config\components\drivers\spi_display_bus.json
struct spi_display_bus_config {
    const char* name = "spi_display_bus";
    const char* type = "bus";
    const char* version = "1.0.0";
    const char* author = "config/authors/ai_agent.json";
    const char* description = "Write-only SPI bus dedicated to display controllers.";
    const char* created = "2025-11-01";
    const char* component_type = "bus_interface";
    const char* relative_filename = "config/components/drivers/spi_display_bus.json";
    struct software_t {
        const char* init_function = "spi_display_bus_init";
        const char* act_function = "spi_display_bus_act";
    } software;
};

// ---------------------------------------------------------------------------
// Function prototypes
// ---------------------------------------------------------------------------
esp_err_t gc9a01_init(void);
void gc9a01_act(void);
esp_err_t generic_spi_data_driver_init(void);
void generic_spi_data_driver_act(void);
esp_err_t generic_spi_display_init(void);
void generic_spi_display_act(void);
esp_err_t goblin_eye_init(void);
void goblin_eye_act(void);
esp_err_t goblin_left_eye_init<T>(void);
void goblin_left_eye_act<T>(void);
esp_err_t goblin_right_eye_init(void);
void goblin_right_eye_act(void);
esp_err_t spi_bus_init(void);
void spi_bus_act(void);
esp_err_t spi_display_bus_init(void);
void spi_display_bus_act(void);

// Declarations from config\components\hardware\gc9a01.hdr
#ifndef GC9A01_HPP
#define GC9A01_HPP

/**
 * @file gc9a01.hpp
 * @brief GC9A01 240x240 circular display hardware driver
 * @author P32 Animatronic Bot Project
 */

#include "core/memory/SharedMemory.hpp"
#include <cstdint>

// Forward declaration
struct GC9A01_Pixel;

// Global InitialPixel - must be set before allocating buffers containing Pixels
extern GC9A01_Pixel GC9A01_InitialPixel;

/**
 * @brief Pixel struct for GC9A01 display (RGB565 format)
 * Simple bit-field representation for RGB565 color format
 */
struct GC9A01_Pixel
{
    unsigned int red : 5;
    unsigned int green : 6;
    unsigned int blue : 5;
    
    // Default constructor using InitialPixel
    GC9A01_Pixel() 
    {
        *this = GC9A01_InitialPixel;
    }
    
    // Constexpr constructor for static colors
    constexpr GC9A01_Pixel(unsigned int r, unsigned int g, unsigned int b)
        : red(r), green(g), blue(b)
    {}
    
    // Copy constructor
    GC9A01_Pixel(const GC9A01_Pixel& other) 
        : red(other.red), green(other.green), blue(other.blue)
    {}
    
    // Assignment operator
    GC9A01_Pixel& operator=(const GC9A01_Pixel& other)
    {
        red = other.red;
        green = other.green;
        blue = other.blue;
        return *this;
    }
    
    // Static color constants
    static constexpr GC9A01_Pixel Red() { return GC9A01_Pixel(31, 0, 0); }
    static constexpr GC9A01_Pixel Green() { return GC9A01_Pixel(0, 63, 0); }
    static constexpr GC9A01_Pixel Blue() { return GC9A01_Pixel(0, 0, 31); }
    static constexpr GC9A01_Pixel Black() { return GC9A01_Pixel(0, 0, 0); }
    static constexpr GC9A01_Pixel White() { return GC9A01_Pixel(31, 63, 31); }
};

// Type alias to use 'Pixel' instead of 'GC9A01_Pixel'
using Pixel = GC9A01_Pixel;

// GC9A01 Display Specifications
#define GC9A01_WIDTH  240
#define GC9A01_HEIGHT 240
#define GC9A01_PIXELS (GC9A01_WIDTH * GC9A01_HEIGHT)

/**
 * @brief Initialize GC9A01 hardware driver using generic SPI display
 * Called once during system startup
 */
esp_err_t gc9a01_init(void);

/**
 * @brief Send current frame buffer to GC9A01 display using generic SPI display
 * Reads currentFrame set by higher-level components
 */
void gc9a01_act(void);

/**
 * @brief Display Buffer Interface - get total frame size in pixels
 * @return Total number of pixels in frame (57,600)
 */
size_t getFrameSize(void);

/**
 * @brief Display Buffer Interface - get frame row size in pixels
 * @return Number of pixels per row (240)
 */
size_t getFrameRowSize(void);

/**
 * @brief Get display size in pixels
 * @return Total number of pixels in one frame (width * height)
 */
size_t getDisplaySize(void);

#endif // GC9A01_HPP

// Declarations from config\components\creature_specific\goblin_eye.hdr
// goblin_eye.hdr
#ifndef GOBLIN_EYE_HDR
#define GOBLIN_EYE_HDR

#include "esp_err.h"
#include "config/components/hardware/gc9a01.hdr"  // For Pixel type

// Global variables for spi_display_bus compatibility
// These are set by goblin_eye_act() to provide chunked data interface
extern Pixel* goblin_eye_chunk_buffer;
extern uint16_t goblin_eye_chunk_width;
extern uint16_t goblin_eye_chunk_height;

// Global flag indicating whether child components should initialize hardware
// Set by goblin_eye_init() based on call count (true every 8th call)
extern bool goblin_eye_should_init_hardware;

esp_err_t goblin_eye_init(void);
void goblin_eye_act(void);

#endif // GOBLIN_EYE_HDR

// Declarations from config\components\creature_specific\goblin_left_eye.hdr
// goblin_left_eye component header
// Additional declarations beyond init/act

#ifndef GOBLIN_LEFT_EYE_COMPONENT_H
#define GOBLIN_LEFT_EYE_COMPONENT_H

#include <stdint.h>

/**
 * @brief Get pointer to left eye display buffer
 * @return Pointer to Pixel array, or nullptr if not initialized
 */
Pixel* goblin_left_eye_get_buffer(void);

#endif // GOBLIN_LEFT_EYE_COMPONENT_H

// Declarations from config\components\creature_specific\goblin_right_eye.hdr
// goblin_right_eye component header
// Additional declarations beyond init/act

#ifndef GOBLIN_RIGHT_EYE_COMPONENT_H
#define GOBLIN_RIGHT_EYE_COMPONENT_H

#include <stdint.h>

/**
 * @brief Get pointer to right eye display buffer
 * @return Pointer to Pixel array, or nullptr if not initialized
 */
Pixel* goblin_right_eye_get_buffer(void);

#endif // GOBLIN_RIGHT_EYE_COMPONENT_H

// Declarations from config\components\interfaces\spi_display_bus.hdr
// SPI display bus component header
// Exposes current SPI pin assignment for display devices

#ifndef SPI_DISPLAY_BUS_H
#define SPI_DISPLAY_BUS_H

#include "esp_err.h"
#include "driver/spi_master.h"
#include <stdio.h>

struct spi_display_pinset_t {
    spi_display_pinset_t()
        : mosi(-1), clk(-1), cs(-1), dc(-1), bl(-1), rst(-1), handle(nullptr) {}

    int mosi;
    int clk;
    int cs;
    int dc;
    int bl;
    int rst;
    spi_device_handle_t handle;

    void print() {
        printf("SPI_DISPLAY bus: mosi=%d, sclk=%d, cs=%d, dc=%d\n", mosi, clk, cs, dc);
    }
};

extern spi_display_pinset_t cur_spi_display_pin;

esp_err_t spi_display_bus_init(void);
void spi_display_bus_act(void);

#endif // SPI_DISPLAY_BUS_H

#endif // TEST_HEAD_COMPONENT_FUNCTIONS_HPP
