#ifndef GOBLIN_TORSO_COMPONENT_FUNCTIONS_HPP
#define GOBLIN_TORSO_COMPONENT_FUNCTIONS_HPP

#include <cstddef>
#include <cstdint>
#include "esp_err.h"

// Auto-generated by tools/generate_tables.py
// Subsystem: goblin_torso
// Controller: ESP32_S3_DEVKITC_1

// Component definition sourced from config\components\system\bluetooth_central.json
struct bluetooth_central_config {
    const char* relative_filename = "config/components/system/bluetooth_central.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "bluetooth_central";
    const char* component_type = "SYSTEM_LEVEL";
    const char* description = "Bluetooth Low Energy (BLE) central controller - mobile app connectivity";
    const char* created = "2025-10-15";
    struct timing_t {
        int hitCount = 75;
        const char* description = "BLE management every 7.5 seconds";
    } timing;
    struct system_requirements_t {
        const char* min_controller = "ESP32";
        const char* required_features[1] = { "BLE_CENTRAL" };
        const char* memory_footprint_kb = "64";
        const char* cpu_usage_percent = "3-8";
    } system_requirements;
    struct ble_config_t {
        const char* device_name = "Goblin_Bot";
        bool auto_advertise = true;
        int connection_timeout_s = 30;
    } ble_config;
    const char* responsibilities[4] = { "Advertise BLE services", "Accept mobile app connections", "Handle BLE command messages", "Report BLE status to telemetry" };
};

// Component definition sourced from config\components\system\debug_controller.json
struct debug_controller_config {
    const char* relative_filename = "config/components/system/debug_controller.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* hardware_type = "DEBUG_CONTROLLER";
    const char* component_type = "SYSTEM_SERVICE";
    const char* name = "debug_controller";
    const char* subsystem = "SYSTEM";
    const char* description = "System-level debug flag controller that manages debugging state via Environment SharedMemory";
    int hitCount = 100;
    struct software_t {
        const char* init_function = "debug_controller_init";
        const char* act_function = "debug_controller_act";
    } software;
    struct debug_config_t {
        bool default_debugging_enabled = true;
        bool default_verbose_logging = true;
        bool default_performance_monitoring = false;
        bool default_display_diagnostics = true;
    } debug_config;
};

// Component definition sourced from config\subsystems\goblin_torso.json
struct goblin_torso_config {
    const char* relative_filename = "config/subsystems/goblin_torso.json";
    const char* version = "3.0.0";
    const char* author = "config/author.json";
    const char* subsystem_type = "TORSO";
    const char* subsystem_id = "goblin_torso_v1";
    const char* description = "Goblin torso subsystem - Master controller with WiFi, and system coordination";
    const char* created = "2025-10-15";
    const char* controller = "ESP32_S3_DEVKITC_1";
    const char* coordinate_system = "skull_3d";
    const char* reference_point = "spine_base";
    const char* units = "MILLIMETERS";
    const char* name = "goblin_torso";
    const char* component_type = "SUBSYSTEM_ASSEMBLY";
    struct timing_t {
        int hitCount = 50;
        const char* description = "Torso coordination every 5 seconds";
    } timing;
    const char* former_components[5] = { "config/components/positioned/spine_flexion_servo.json", "config/components/positioned/spine_extension_servo.json", "config/components/positioned/waist_rotation_servo.json", "config/components/positioned/torso_status_led.json", "config/components/positioned/torso_speaker.json" };
    struct wifi_config_t {
        const char* mode = "STATION";
        const char* ssid = "CONFIGURED_AT_RUNTIME";
        const char* password = "CONFIGURED_AT_RUNTIME";
        const char* static_ip = "192.168.1.100";
        const char* gateway = "192.168.1.1";
        const char* subnet = "255.255.255.0";
        const char* hostname = "goblin-torso-master";
    } wifi_config;
    struct telemetry_config_t {
        const char* mqtt_broker = "CONFIGURED_AT_RUNTIME";
        int mqtt_port = 1883;
        int publish_interval_ms = 5000;
        struct topics_t {
            const char* status = "goblin/torso/status";
            const char* sensors = "goblin/sensors/all";
            const char* commands = "goblin/commands/input";
            const char* diagnostics = "goblin/diagnostics/all";
        } topics;
    } telemetry_config;
    struct shape_assembly_t {
        const char* type = "TORSO_FRAME";
        const char* scad_file = "assets/shapes/scad/subsystems/goblin_torso_frame.scad";
        const char* stl_file = "assets/shapes/stl/subsystems/goblin_torso_frame.stl";
        const char* description = "Torso structural frame with servo mounts and electronics bay";
        const char* color_palette = "config/bots/bot_families/fantasy/goblin_family.json";
        struct mounting_points_t {
            struct spine_base_t {
                const char* type = "servo_mount";
                int position[3] = { 0, 0, 0 };
                const char* units = "mm";
                const char* description = "Spine base servo mount";
            } spine_base;
            struct spine_mid_t {
                const char* type = "servo_mount";
                int position[3] = { 0, 0, 150 };
                const char* units = "mm";
                const char* description = "Spine mid-section servo mount";
            } spine_mid;
            struct waist_t {
                const char* type = "servo_mount";
                int position[3] = { 0, 0, -50 };
                const char* units = "mm";
                const char* description = "Waist rotation servo mount";
            } waist;
            struct shoulder_left_t {
                const char* type = "ball_socket";
                int position[3] = { -120, 0, 250 };
                const char* units = "mm";
                const char* description = "Left shoulder attachment point";
            } shoulder_left;
            struct shoulder_right_t {
                const char* type = "ball_socket";
                int position[3] = { 120, 0, 250 };
                const char* units = "mm";
                const char* description = "Right shoulder attachment point";
            } shoulder_right;
            struct hip_left_t {
                const char* type = "ball_socket";
                int position[3] = { -80, 0, -100 };
                const char* units = "mm";
                const char* description = "Left hip attachment point";
            } hip_left;
            struct hip_right_t {
                const char* type = "ball_socket";
                int position[3] = { 80, 0, -100 };
                const char* units = "mm";
                const char* description = "Right hip attachment point";
            } hip_right;
            struct neck_socket_t {
                const char* type = "ball_socket";
                int position[3] = { 0, 0, 300 };
                const char* units = "mm";
                const char* description = "Neck/head attachment point";
            } neck_socket;
            struct electronics_bay_t {
                const char* type = "enclosure";
                int position[3] = { 0, -50, 150 };
                int dimensions[3] = { 100, 80, 60 };
                const char* units = "mm";
                const char* description = "Main electronics bay for ESP32-S3, power distribution, antenna";
            } electronics_bay;
        } mounting_points;
    } shape_assembly;
    struct articulation_t {
        int degrees_of_freedom = 3;
        int spine_flexion_range_degrees = 60;
        int spine_extension_range_degrees = 45;
        int waist_rotation_range_degrees = 180;
    } articulation;
    struct mass_properties_t {
        const char* total_weight_g = "850";
        int center_of_gravity[3] = { 0, 0, 150 };
        const char* balance_point = "spine_base";
    } mass_properties;
    struct power_requirements_t {
        const char* voltage = "6V";
        const char* estimated_current_draw_a = "4.5";
        const char* servo_power_w = "18.0";
        const char* electronics_power_w = "5.0";
        const char* total_power_w = "23.0";
    } power_requirements;
    struct processing_responsibilities_t {
        const char* description = "Torso serves as master coordinator with highest processing power";
        const char* tasks[9] = { "WiFi connectivity management", "Bluetooth central device", "MQTT telemetry hub", "System-wide coordination", "High-level behavior planning", "Balance and posture control", "Power monitoring and distribution", "Watchdog and health checks", "Command routing to slave nodes" };
    } processing_responsibilities;
};

// Component definition sourced from config\components\system\network_monitor.json
struct network_monitor_config {
    const char* relative_filename = "config/components/system/network_monitor.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "network_monitor";
    const char* component_type = "SYSTEM_LEVEL";
    const char* description = "Network connectivity monitoring - WiFi signal strength, connection status";
    const char* created = "2025-10-15";
    struct timing_t {
        int hitCount = 50;
        const char* description = "Network check every 5 seconds";
    } timing;
    struct system_requirements_t {
        const char* min_controller = "ESP32";
        const char* required_features[1] = { "WIFI_STA" };
        const char* memory_footprint_kb = "24";
        const char* cpu_usage_percent = "1-3";
    } system_requirements;
    struct monitoring_metrics_t {
        bool wifi_rssi = true;
        bool connection_quality = true;
        bool packet_loss = true;
        bool latency_ms = true;
    } monitoring_metrics;
    const char* responsibilities[4] = { "Monitor WiFi signal strength (RSSI)", "Detect connection drops", "Report connectivity status to telemetry", "Trigger reconnection on failure" };
};

// Component definition sourced from config\components\system\power_monitor.json
struct power_monitor_config {
    const char* relative_filename = "config/components/system/power_monitor.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "power_monitor";
    const char* component_type = "SYSTEM_LEVEL";
    const char* description = "Power monitoring - battery voltage, current consumption, remaining capacity";
    const char* created = "2025-10-15";
    struct timing_t {
        int hitCount = 200;
        const char* description = "Power check every 20 seconds";
    } timing;
    struct system_requirements_t {
        const char* min_controller = "ESP32";
        const char* required_features[1] = { "ADC" };
        const char* memory_footprint_kb = "20";
        const char* cpu_usage_percent = "1-2";
    } system_requirements;
    struct monitoring_config_t {
        int voltage_adc_pin = 36;
        int current_adc_pin = 39;
        int low_battery_threshold_mv = 3300;
        int critical_battery_threshold_mv = 3000;
    } monitoring_config;
    const char* responsibilities[4] = { "Measure battery voltage via ADC", "Calculate remaining battery percentage", "Trigger low-power mode on low battery", "Report power status to telemetry" };
};

// Component definition sourced from config\components\hardware\servo_sg90_micro.json
struct servo_sg90_micro_config {
    const char* relative_filename = "config/components/hardware/servo_sg90_micro.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "servo_sg90_micro";
    const char* component_type = "SERVO_MOTOR";
    const char* hardware_id = "SERVO_SG90_MICRO";
    const char* description = "Micro servo motor for precise position control in small animatronics";
    const char* created = "2025-10-12";
    int hitCount = 1;
    struct physical_specifications_t {
        const char* dimensions = "23x12.2x29 MM";
        const char* weight = "9 G";
        const char* shaft_diameter = "4 MM";
        int mounting_holes = 2;
        const char* rotation_range = "180 DEG";
        const char* operating_voltage = "4.8V-6V";
        const char* stall_current = "650 MA";
        const char* operating_current = "220 MA";
    } physical_specifications;
    struct electrical_requirements_t {
        const char* power_supply_voltage = "5V";
        const char* control_voltage = "3.3V";
        const char* interface_type = "PWM";
        const char* pwm_frequency = "50 HZ";
        const char* pulse_width_range = "1-2 MS";
        const char* logic_compatibility = "3.3V_TOLERANT";
    } electrical_requirements;
    struct gpio_requirements_t {
        int control_pin = 1;
        int power_pins = 1;
        int ground_pins = 1;
        int total_connections = 3;
    } gpio_requirements;
    struct performance_specifications_t {
        const char* rotation_speed = "0.1 SEC/60_DEG";
        const char* torque = "1.8 KG_CM";
        const char* precision = "1 DEG";
        const char* backlash = "1 DEG";
        const char* operating_temperature = "-30_TO_60_C";
        const char* duty_cycle = "CONTINUOUS";
    } performance_specifications;
    struct control_capabilities_t {
        bool position_feedback = false;
        bool speed_control = false;
        bool torque_limiting = false;
        bool smooth_acceleration = true;
        bool calibration_required = true;
    } control_capabilities;
    const char* use_cases[8] = { "eye_movement", "ear_articulation", "mouth_opening", "head_turning", "tail_wagging", "wing_flapping", "jaw_movement", "eyebrow_raising" };
    struct family_suitability_t {
        const char* robot = "GOOD";
        const char* android = "EXCELLENT";
        const char* goblin = "EXCELLENT";
        const char* vampire = "GOOD";
        const char* zombie = "MODERATE";
        const char* ghost = "POOR";
        const char* dragon = "EXCELLENT";
        const char* cat = "EXCELLENT";
        const char* bear = "GOOD";
    } family_suitability;
    struct mounting_requirements_t {
        bool servo_horn_required = true;
        const char* mounting_bracket = "OPTIONAL";
        const char* vibration_damping = "RECOMMENDED";
        const char* wire_management = "3_WIRE_PIGTAIL";
    } mounting_requirements;
    struct software_t {
        const char* init_function = "servo_sg90_micro_init";
        const char* act_function = "servo_sg90_micro_act";
    } software;
    const char* hardware_type = "SERVO_MOTOR";
};

// Component definition sourced from config\components\positioned\spine_extension_servo.json
struct spine_extension_servo_config {
    const char* component_type = "POSITIONED_COMPONENT";
    struct position_t {
        const char* units = "INCH";
        const char* x = "0.0 INCH";
        const char* coordinate_system = "skull_3d";
        const char* z = "0.0 INCH";
        const char* reference_point = "nose_center";
        const char* y = "0.0 INCH";
    } position;
    const char* name = "spine_extension_servo";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    struct software_t {
        const char* act_function = "spine_extension_servo_act";
        const char* init_function = "spine_extension_servo_init";
        int hitCount = 10;
    } software;
    const char* relative_filename = "config/components/positioned/spine_extension_servo.json";
};

// Component definition sourced from config\components\positioned\spine_flexion_servo.json
struct spine_flexion_servo_config {
    const char* component_type = "POSITIONED_COMPONENT";
    struct position_t {
        const char* units = "INCH";
        const char* x = "0.0 INCH";
        const char* coordinate_system = "skull_3d";
        const char* z = "0.0 INCH";
        const char* reference_point = "nose_center";
        const char* y = "0.0 INCH";
    } position;
    const char* name = "spine_flexion_servo";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    struct software_t {
        const char* act_function = "spine_flexion_servo_act";
        const char* init_function = "spine_flexion_servo_init";
        int hitCount = 10;
    } software;
    const char* relative_filename = "config/components/positioned/spine_flexion_servo.json";
};

// Component definition sourced from config\components\system\system_core.json
struct system_core_config {
    const char* relative_filename = "config/components/system/system_core.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "system_core";
    const char* component_type = "SYSTEM_LEVEL";
    const char* description = "Core system management - initialization, health checks, error handling";
    const char* created = "2025-10-15";
    struct timing_t {
        int hitCount = 100;
        const char* description = "Core system check every 10 seconds";
    } timing;
    struct system_requirements_t {
        const char* min_controller = "ESP32";
        const char* required_features[1] = { "FreeRTOS" };
        const char* memory_footprint_kb = "32";
        const char* cpu_usage_percent = "1-2";
    } system_requirements;
    const char* responsibilities[5] = { "Initialize FreeRTOS tasks", "Manage system heap memory", "Handle critical errors", "Coordinate subsystem initialization", "Provide system status reporting" };
};

// Component definition sourced from config\components\system\telemetry_hub.json
struct telemetry_hub_config {
    const char* relative_filename = "config/components/system/telemetry_hub.json";
    const char* version = "3.0.0";
    const char* author = "config/author.json";
    const char* name = "telemetry_hub";
    const char* component_type = "SYSTEM_LEVEL";
    const char* description = "Central telemetry aggregation and publishing hub - collects data from all subsystems";
    const char* created = "2025-10-15";
    struct timing_t {
        int hitCount = 75;
        const char* description = "Telemetry publish cycle every 7.5 seconds";
    } timing;
    struct system_requirements_t {
        const char* min_controller = "ESP32_S3";
        const char* required_features[2] = { "WIFI_STA", "ESP_NOW" };
        const char* memory_footprint_kb = "96";
        const char* cpu_usage_percent = "3-8";
    } system_requirements;
    struct mqtt_configuration_t {
        const char* broker = "CONFIGURED_AT_RUNTIME";
        int port = 1883;
        const char* client_id = "goblin_torso_master";
        int qos = 1;
        bool retain = false;
        int keepalive_s = 60;
        bool auto_reconnect = true;
    } mqtt_configuration;
    struct telemetry_sources_t {
        const char* subsystem_health[5] = { "HEAD_NODE", "ARM_LEFT_NODE", "ARM_RIGHT_NODE", "LEG_LEFT_NODE", "LEG_RIGHT_NODE" };
        const char* sensor_data[4] = { "distance_sensors", "touch_sensors", "temperature_sensors", "voltage_monitors" };
        const char* system_metrics[5] = { "cpu_usage", "memory_usage", "wifi_signal_strength", "mesh_node_count", "uptime" };
    } telemetry_sources;
    struct publish_topics_t {
        const char* system_status = "goblin/system/status";
        const char* subsystem_health = "goblin/subsystems/health";
        const char* sensor_readings = "goblin/sensors/data";
        const char* performance_metrics = "goblin/performance/metrics";
        const char* error_reports = "goblin/errors/log";
    } publish_topics;
    struct subscribe_topics_t {
        const char* commands = "goblin/commands/input";
        const char* configuration = "goblin/config/update";
        const char* firmware_ota = "goblin/firmware/update";
    } subscribe_topics;
    const char* responsibilities[8] = { "Aggregate data from all mesh nodes", "Format telemetry into JSON payloads", "Publish to MQTT broker periodically", "Subscribe to command topics", "Route remote commands to subsystems", "Log system events and errors", "Support OTA firmware updates", "Provide REST API for local control" };
};

// Component definition sourced from config\components\positioned\torso_speaker.json
struct torso_speaker_config {
    const char* component_type = "POSITIONED_COMPONENT";
    struct position_t {
        const char* units = "INCH";
        const char* x = "0.0 INCH";
        const char* coordinate_system = "skull_3d";
        const char* z = "0.0 INCH";
        const char* reference_point = "nose_center";
        const char* y = "0.0 INCH";
    } position;
    const char* name = "torso_speaker";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    struct software_t {
        const char* act_function = "torso_speaker_act";
        const char* init_function = "torso_speaker_init";
        int hitCount = 10;
    } software;
    const char* relative_filename = "config/components/positioned/torso_speaker.json";
};

// Component definition sourced from config\components\positioned\torso_status_led.json
struct torso_status_led_config {
    const char* component_type = "POSITIONED_COMPONENT";
    struct position_t {
        const char* units = "INCH";
        const char* x = "0.0 INCH";
        const char* coordinate_system = "skull_3d";
        const char* z = "0.0 INCH";
        const char* reference_point = "nose_center";
        const char* y = "0.0 INCH";
    } position;
    const char* name = "torso_status_led";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    struct software_t {
        const char* act_function = "torso_status_led_act";
        const char* init_function = "torso_status_led_init";
        int hitCount = 10;
    } software;
    const char* relative_filename = "config/components/positioned/torso_status_led.json";
};

// Component definition sourced from config\components\positioned\waist_rotation_servo.json
struct waist_rotation_servo_config {
    const char* component_type = "POSITIONED_COMPONENT";
    struct position_t {
        const char* units = "INCH";
        const char* x = "0.0 INCH";
        const char* coordinate_system = "skull_3d";
        const char* z = "0.0 INCH";
        const char* reference_point = "nose_center";
        const char* y = "0.0 INCH";
    } position;
    const char* name = "waist_rotation_servo";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    struct software_t {
        const char* act_function = "waist_rotation_servo_act";
        const char* init_function = "waist_rotation_servo_init";
        int hitCount = 10;
    } software;
    const char* relative_filename = "config/components/positioned/waist_rotation_servo.json";
};

// Component definition sourced from config\components\system\watchdog.json
struct watchdog_config {
    const char* relative_filename = "config/components/system/watchdog.json";
    const char* version = "1.0.0";
    const char* author = "config/author.json";
    const char* name = "watchdog";
    const char* component_type = "SYSTEM_LEVEL";
    const char* description = "Hardware watchdog timer - system health monitoring and automatic recovery";
    const char* created = "2025-10-15";
    struct timing_t {
        int hitCount = 500;
        const char* description = "Watchdog heartbeat every 50 seconds";
    } timing;
    struct system_requirements_t {
        const char* min_controller = "ESP32";
        const char* required_features[1] = { "WATCHDOG_TIMER" };
        const char* memory_footprint_kb = "16";
        const char* cpu_usage_percent = "1";
    } system_requirements;
    struct watchdog_config_t {
        int timeout_seconds = 60;
        bool auto_recovery = true;
        bool panic_on_timeout = false;
    } watchdog_config;
    const char* responsibilities[4] = { "Reset watchdog timer periodically", "Monitor system responsiveness", "Trigger system reboot on hang", "Log watchdog resets to telemetry" };
};

// Component definition sourced from config\components\system\wifi_station.json
struct wifi_station_config {
    const char* relative_filename = "config/components/system/wifi_station.json";
    const char* version = "3.0.0";
    const char* author = "config/author.json";
    const char* name = "wifi_station";
    const char* component_type = "SYSTEM_LEVEL";
    const char* description = "WiFi station connectivity for cloud integration and remote control";
    const char* created = "2025-10-15";
    struct timing_t {
        int hitCount = 50;
        const char* description = "WiFi status check every 5 seconds";
    } timing;
    struct system_requirements_t {
        const char* min_controller = "ESP32_S3";
        const char* required_features[1] = { "WIFI_STA" };
        const char* memory_footprint_kb = "128";
        const char* cpu_usage_percent = "2-5";
    } system_requirements;
    struct wifi_configuration_t {
        const char* mode = "STATION";
        bool auto_connect = true;
        int reconnect_interval_ms = 30000;
        int max_reconnect_attempts = 10;
        const char* power_save_mode = "MODEM_SLEEP";
    } wifi_configuration;
    struct network_services_t {
        bool dhcp_client = true;
        bool static_ip_fallback = true;
        bool dns_enabled = true;
        bool ntp_sync = true;
        bool mdns_responder = true;
    } network_services;
    const char* responsibilities[7] = { "Connect to WiFi access point", "Maintain persistent connection", "Handle reconnection on signal loss", "Manage IP address configuration", "Sync system time via NTP", "Provide mDNS discovery", "Report connection status to telemetry" };
};

// ---------------------------------------------------------------------------
// Function prototypes
// ---------------------------------------------------------------------------
esp_err_t bluetooth_central_init(void);
void bluetooth_central_act(void);
esp_err_t debug_controller_init(void);
void debug_controller_act(void);
esp_err_t goblin_torso_init(void);
void goblin_torso_act(void);
esp_err_t network_monitor_init(void);
void network_monitor_act(void);
esp_err_t power_monitor_init(void);
void power_monitor_act(void);
esp_err_t servo_sg90_micro_init(void);
void servo_sg90_micro_act(void);
esp_err_t spine_extension_servo_init(void);
void spine_extension_servo_act(void);
esp_err_t spine_flexion_servo_init(void);
void spine_flexion_servo_act(void);
esp_err_t system_core_init(void);
void system_core_act(void);
esp_err_t telemetry_hub_init(void);
void telemetry_hub_act(void);
esp_err_t torso_speaker_init(void);
void torso_speaker_act(void);
esp_err_t torso_status_led_init(void);
void torso_status_led_act(void);
esp_err_t waist_rotation_servo_init(void);
void waist_rotation_servo_act(void);
esp_err_t watchdog_init(void);
void watchdog_act(void);
esp_err_t wifi_station_init(void);
void wifi_station_act(void);

#endif // GOBLIN_TORSO_COMPONENT_FUNCTIONS_HPP
